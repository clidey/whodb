name: Deploy to Apple App Store

on:
  workflow_call:
    inputs:
      version:
        description: 'Version being deployed'
        required: true
        type: string
      stage-only:
        description: 'Stage only mode (TestFlight only)'
        required: false
        type: boolean
        default: false
      release-notes:
        description: 'Release notes for App Store (What is New)'
        required: false
        type: string
        default: ''

permissions:
  contents: read
  actions: write

jobs:
  package-mac-app-store:
    name: Package for Mac App Store
    runs-on: macos-latest
    environment: deploy-apple
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: block
          allowed-endpoints: >
            github.com:443

      - name: Checkout
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0

      - name: Download macOS DMG
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
        with:
          name: desktop-darwin-dmg
          path: desktop-builds/

      - name: Download macOS App Bundle (MAS)
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
        with:
          name: desktop-darwin-mas-app
          path: desktop-builds/

      # No need to download entitlements - the app is already signed with them

      - name: Generate Homebrew cask
        run: |
          VERSION="${{ inputs.version }}"

          # Find DMG file
          DMG_PATH=$(find desktop-builds -name "*.dmg" | head -1)

          if [ -z "$DMG_PATH" ]; then
            echo "âš ï¸  No DMG file found, skipping Homebrew cask generation"
            exit 0
          fi

          # Generate cask using script
          .github/scripts/generate-homebrew-cask.sh "$VERSION" "$DMG_PATH" whodb.rb

          # Create usage instructions
          cat > HOMEBREW_TESTING.md <<EOF
          # Local Homebrew Cask Testing

          This cask file was generated for WhoDB v${VERSION}.

          ## Local Testing Instructions:

          1. Download the whodb.rb file from this workflow run
          2. Install locally:
             \`\`\`bash
             brew install --cask whodb.rb
             \`\`\`

          3. Test the app:
             \`\`\`bash
             open -a WhoDB
             \`\`\`

          4. Uninstall when done:
             \`\`\`bash
             brew uninstall --cask whodb
             \`\`\`

          ## Submit to Homebrew (after production release):

          1. Fork homebrew-cask repository
          2. Create branch: \`update-whodb-${VERSION}\`
          3. Add/update \`Casks/w/whodb.rb\` with this file
          4. Submit PR with title: \`whodb ${VERSION}\` (or \`whodb ${VERSION} (new cask)\` if first submission)
          EOF

          echo ""
          echo "ðŸ“‹ Testing instructions created"

      - name: Upload Homebrew cask
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: homebrew-cask-apple
          path: |
            whodb.rb
            HOMEBREW_TESTING.md
          retention-days: 30

      - name: Check for MAS app bundle
        id: check_app
        run: |
          # Look for the MAS app bundle (should be WhoDB.app with proper case)
          APP_PATHS=(
            "desktop-builds/WhoDB.app"
            "desktop-builds/build/darwin/universal/WhoDB.app"
            "desktop-builds/darwin/universal/WhoDB.app"
          )

          APP_PATH=""
          for path in "${APP_PATHS[@]}"; do
            if [ -d "$path" ]; then
              APP_PATH="$path"
              echo "âœ… Found MAS app bundle at: $APP_PATH"
              break
            fi
          done

          if [ -z "$APP_PATH" ]; then
            echo "âŒ MAS app bundle not found"
            echo "Available files:"
            find desktop-builds -name "*.app" -type d || true
            exit 1
          fi

          echo "app_path=$APP_PATH" >> $GITHUB_OUTPUT

      - name: Import Mac App Store Installer Certificate
        env:
          MAS_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_MAS_CERTIFICATES_P12 }}
          MAS_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_MAS_CERTIFICATES_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          if [ -z "$MAS_CERTIFICATE_P12_BASE64" ]; then
            echo "âŒ ERROR: Mac App Store certificates are required for PKG signing"
            echo "Please configure APPLE_MAS_CERTIFICATES_P12 and APPLE_MAS_CERTIFICATES_PASSWORD secrets"
            exit 1
          fi

          if [ -z "$MAS_CERTIFICATE_PASSWORD" ]; then
            echo "âŒ ERROR: APPLE_MAS_CERTIFICATES_PASSWORD is required"
            exit 1
          fi

          echo "ðŸ” Setting up keychain for Mac App Store PKG signing..."

          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/mas_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/mas-signing.keychain-db
          KEYCHAIN_PASSWORD_VALUE="${KEYCHAIN_PASSWORD:-$(uuidgen)}"

          # Decode certificate
          echo "$MAS_CERTIFICATE_P12_BASE64" | base64 --decode -o "$CERTIFICATE_PATH"

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD_VALUE" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD_VALUE" "$KEYCHAIN_PATH"

          # Import certificate to keychain
          security import "$CERTIFICATE_PATH" -P "$MAS_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"

          # Set keychain search list
          security list-keychain -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | sed s/\"//g)

          # Allow productbuild to access keychain
          security set-key-partition-list -S apple-tool:,apple:,productbuild: \
            -s -k "$KEYCHAIN_PASSWORD_VALUE" "$KEYCHAIN_PATH"

          echo "âœ… Mac App Store installer certificate imported successfully"

          # List available signing identities for verification
          echo "Available certificates in keychain:"
          security find-identity -v -p basic "$KEYCHAIN_PATH"

          echo ""
          echo "Looking for installer certificate..."
          # Check if we have the installer cert (don't fail if not found)
          if security find-identity -v -p basic "$KEYCHAIN_PATH" | grep -q "Mac Installer Distribution\|3rd Party Mac Developer Installer"; then
            INSTALLER_CERT=$(security find-identity -v -p basic "$KEYCHAIN_PATH" | grep "Mac Installer Distribution\|3rd Party Mac Developer Installer" | head -1 | awk '{print $2}')
            echo "Found installer certificate: $INSTALLER_CERT"
          else
            echo "âš ï¸  No Mac Installer Distribution certificate found"
            echo "Available certificates:"
            security find-identity -v "$KEYCHAIN_PATH"
          fi

      - name: Package Mac App Store build
        env:
          MAS_CERT_INSTALLER: ${{ secrets.APPLE_MAS_CERT_INSTALLER }}
        run: |
          echo "ðŸ“¦ Packaging Mac App Store build..."

          # Validate installer certificate
          if [ -z "$MAS_CERT_INSTALLER" ]; then
            echo "âŒ ERROR: APPLE_MAS_CERT_INSTALLER is required"
            exit 1
          fi

          # Find the already-signed MAS app
          APP_PATH="${{ steps.check_app.outputs.app_path }}"
          PKG_PATH="WhoDB_${{ inputs.version }}.pkg"

          if [ ! -d "$APP_PATH" ]; then
            echo "âŒ ERROR: App bundle not found at $APP_PATH"
            exit 1
          fi

          echo "Using pre-signed MAS app: $APP_PATH"

          # CRITICAL FIX: GitHub Actions artifact upload/download loses Unix permissions
          # Restore execute permissions that were set during build
          echo "ðŸ”§ Restoring execute permissions (lost during artifact transfer)..."
          chmod +x "$APP_PATH/Contents/MacOS/whodb"
          ls -la "$APP_PATH/Contents/MacOS/whodb"

          # Verify the app is already signed correctly
          echo "Verifying existing signature..."
          codesign --verify --verbose=4 "$APP_PATH"
          codesign --display --entitlements - "$APP_PATH"

          # Create signed PKG installer with Mac Installer Distribution certificate
          echo "ðŸ” Creating signed PKG installer..."
          productbuild --component "$APP_PATH" /Applications \
            --sign "$MAS_CERT_INSTALLER" \
            --identifier "com.clidey.whodb" \
            --version "${{ inputs.version }}" \
            "$PKG_PATH"

          echo "âœ… Signed PKG created"

          # Verify package
          if [ -f "$PKG_PATH" ]; then
            echo "Package size: $(du -h "$PKG_PATH" | cut -f1)"
            pkgutil --check-signature "$PKG_PATH"
          else
            echo "âŒ Failed to create PKG"
            exit 1
          fi

      - name: Upload Mac App Store package
        uses: actions/upload-artifact@330a01c490aca151604b8cf639adc76d48f6c5d4 # v5.0.0
        with:
          name: mac-app-store-package
          path: "*.pkg"
          retention-days: 1

      - name: Cleanup Keychain
        if: always()
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/mas-signing.keychain-db
          if [ -f "$KEYCHAIN_PATH" ]; then
            echo "ðŸ§¹ Cleaning up Mac App Store keychain..."
            security delete-keychain "$KEYCHAIN_PATH" || true
            echo "âœ… Keychain cleanup complete"
          fi

  deploy-apple-store:
    name: Submit to Apple App Store
    runs-on: macos-latest
    needs: [ package-mac-app-store ]
    environment: deploy-apple
    continue-on-error: ${{ inputs.stage-only }}
    steps:
      - name: Harden Runner
        uses: step-security/harden-runner@95d9a5deda9de15063e7595e9719c11c38c90ae2 # v2.13.2
        with:
          egress-policy: block
          allowed-endpoints: >
            api.appstoreconnect.apple.com:443
            appstoreconnect.apple.com:443
            contentdelivery.itunes.apple.com:443
            github.com:443

      - name: Checkout for scripts
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0

      - name: Check Apple Store credentials
        id: check_creds
        run: |
          echo "ðŸ” Checking Apple Store credentials..."

          if [ -z "${{ secrets.APP_STORE_CONNECT_API_KEY }}" ] || \
             [ -z "${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}" ] || \
             [ -z "${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}" ]; then
            echo "âŒ ERROR: App Store Connect API credentials are required"
            echo "Please configure APP_STORE_CONNECT_API_KEY, APP_STORE_CONNECT_API_KEY_ID, and APP_STORE_CONNECT_ISSUER_ID secrets"
            exit 1
          fi

          echo "âœ… All App Store Connect API credentials configured"
          echo "has_creds=true" >> $GITHUB_OUTPUT

      - name: Download Mac App Store package
        if: steps.check_creds.outputs.has_creds == 'true'
        uses: actions/download-artifact@018cc2cf5baa6db3ef3c5f8a56943fffe632ef53 # v6.0.0
        with:
          name: mac-app-store-package
          path: .

      - name: Setup App Store Connect API key
        if: steps.check_creds.outputs.has_creds == 'true'
        env:
          APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          echo "ðŸ“ Setting up App Store Connect API key..."

          # Create private keys directory
          mkdir -p ~/.appstoreconnect/private_keys

          # Write the API key to file
          echo "$APP_STORE_CONNECT_API_KEY" > ~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8

          # Set proper permissions
          chmod 600 ~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8

          echo "âœ… API key configured"

      - name: Upload to App Store Connect
        if: steps.check_creds.outputs.has_creds == 'true'
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          set -e  # Exit on any error

          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  App Store Connect Upload"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

          # Find PKG file
          PKG_FILE=$(ls *.pkg 2>/dev/null | head -1)

          if [ -z "$PKG_FILE" ]; then
            echo "âŒ ERROR: No PKG file found in current directory"
            echo "ðŸ“ Directory contents:"
            ls -lh
            exit 1
          fi

          echo "ðŸ“¦ Package: $PKG_FILE"
          echo "ðŸ“Š Size: $(du -h "$PKG_FILE" | cut -f1)"
          echo "ðŸ” Authentication: API Key (JWT)"

          if [ "${{ inputs.stage-only }}" = "true" ]; then
            echo "ðŸŽ¯ Mode: STAGE (TestFlight only)"
          else
            echo "ðŸŽ¯ Mode: PRODUCTION (App Store)"
          fi
          echo ""

          # Try multiple upload methods
          echo "ðŸ” Determining upload method..."

          # Method 1: Try finding iTMSTransporter in SharedFrameworks (preferred location)
          TRANSPORTER_PATH="/Applications/Xcode.app/Contents/SharedFrameworks/ContentDeliveryServices.framework/itms/bin/iTMSTransporter"

          # Check all Xcode versions on the system
          if [ ! -f "$TRANSPORTER_PATH" ]; then
            for XCODE_PATH in /Applications/Xcode*.app; do
              TEST_PATH="$XCODE_PATH/Contents/SharedFrameworks/ContentDeliveryServices.framework/itms/bin/iTMSTransporter"
              if [ -f "$TEST_PATH" ]; then
                TRANSPORTER_PATH="$TEST_PATH"
                break
              fi
            done
          fi

          UPLOAD_METHOD=""

          if [ -f "$TRANSPORTER_PATH" ]; then
            echo "âœ… Found iTMSTransporter: $TRANSPORTER_PATH"
            UPLOAD_METHOD="transporter"
          else
            echo "âš ï¸  iTMSTransporter not found in SharedFrameworks"
            echo "ðŸ”„ Falling back to xcrun altool (package uploads still supported)"
            UPLOAD_METHOD="altool"
          fi
          echo ""

          # Verify API key
          API_KEY_PATH="$HOME/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8"

          if [ ! -f "$API_KEY_PATH" ]; then
            echo "âŒ ERROR: API key not found at $API_KEY_PATH"
            echo ""
            echo "Troubleshooting:"
            echo "  â€¢ Verify APP_STORE_CONNECT_API_KEY secret is configured"
            echo "  â€¢ Check 'Setup App Store Connect API key' step completed successfully"
            exit 1
          fi

          echo "âœ… API key found and configured"
          echo ""

          # Validate PKG signature before upload
          echo "ðŸ” Validating package signature..."
          if pkgutil --check-signature "$PKG_FILE" > /dev/null 2>&1; then
            echo "âœ… Package signature valid"
            pkgutil --check-signature "$PKG_FILE" | head -5
          else
            echo "âš ï¸  Warning: Could not verify package signature"
          fi
          echo ""

          # Upload with retry logic
          echo "ðŸ“¤ Starting upload to App Store Connect..."
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

          MAX_ATTEMPTS=3
          ATTEMPT=1
          UPLOAD_SUCCESS=false

          while [ $ATTEMPT -le $MAX_ATTEMPTS ] && [ "$UPLOAD_SUCCESS" = "false" ]; do
            if [ $ATTEMPT -gt 1 ]; then
              echo ""
              echo "ðŸ”„ Retry attempt $ATTEMPT of $MAX_ATTEMPTS..."
              sleep 10  # Wait before retry
            else
              echo "â³ Attempt $ATTEMPT of $MAX_ATTEMPTS..."
            fi

            # Create log file for this attempt
            LOG_FILE="/tmp/transporter_upload_attempt_${ATTEMPT}.log"

            # Run upload based on method
            set +e  # Temporarily disable exit on error

            if [ "$UPLOAD_METHOD" = "transporter" ]; then
              echo "Using iTMSTransporter..."
              "$TRANSPORTER_PATH" \
                -m upload \
                -f "$PKG_FILE" \
                -k "$API_KEY_PATH" \
                -i "$APP_STORE_CONNECT_API_KEY_ID" \
                -issuer "$APP_STORE_CONNECT_ISSUER_ID" \
                -v eXtreme \
                2>&1 | tee "$LOG_FILE"
            else
              echo "Using xcrun altool..."
              # Note: altool upload-app is for IPA/PKG uploads (still supported)
              # Only notarization is deprecated
              xcrun altool \
                --upload-app \
                --type macos \
                --file "$PKG_FILE" \
                --apiKey "$APP_STORE_CONNECT_API_KEY_ID" \
                --apiIssuer "$APP_STORE_CONNECT_ISSUER_ID" \
                --verbose \
                2>&1 | tee "$LOG_FILE"
            fi

            UPLOAD_EXIT_CODE=$?
            set -e  # Re-enable exit on error

            # Check both exit code AND log content for actual success
            if [ $UPLOAD_EXIT_CODE -eq 0 ] && ! grep -q "ERROR:" "$LOG_FILE"; then
              # Different success indicators for different methods
              if [ "$UPLOAD_METHOD" = "altool" ]; then
                # altool success indicators
                if grep -q "No errors uploading" "$LOG_FILE" || grep -q "successfully uploaded" "$LOG_FILE"; then
                  UPLOAD_SUCCESS=true
                  echo ""
                  echo "âœ… Upload completed successfully!"
                else
                  echo ""
                  echo "âš ï¸  altool completed with exit code 0, verifying..."
                  # altool sometimes succeeds without explicit success message
                  if ! grep -q "ERROR" "$LOG_FILE" && ! grep -q "failed" "$LOG_FILE"; then
                    echo "âœ… No errors detected, upload appears successful"
                    UPLOAD_SUCCESS=true
                  fi
                fi
              else
                # iTMSTransporter success indicators
                if grep -q "Successfully uploaded" "$LOG_FILE" || grep -q "Package Summary" "$LOG_FILE" || grep -q "No errors uploading" "$LOG_FILE"; then
                  UPLOAD_SUCCESS=true
                  echo ""
                  echo "âœ… Upload completed successfully!"
                elif grep -q "OSStatus error" "$LOG_FILE"; then
                  # Exit code 0 but OSStatus error present - this is likely a failure
                  echo ""
                  echo "âŒ OSStatus error detected - upload failed"
                  echo "The -10814 error indicates iTMSTransporter couldn't complete the upload"

                  # If this was iTMSTransporter, try switching to altool for next attempt
                  if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                    echo "ðŸ”„ Will retry with altool instead"
                    UPLOAD_METHOD="altool"
                  fi
                else
                  # Exit code 0 but no clear success indicators
                  echo ""
                  echo "âš ï¸  Upload completed with exit code 0, but no success confirmation found"
                  echo "This likely means upload failed - will retry if attempts remain"
                fi
              fi
            else
              echo ""
              echo "âŒ Upload failed with exit code: $UPLOAD_EXIT_CODE"

              # Parse log for common errors
              if grep -q "Could not authenticate" "$LOG_FILE"; then
                echo ""
                echo "ðŸ” Authentication error detected"
                echo "Troubleshooting:"
                echo "  â€¢ Verify API key ID and Issuer ID are correct"
                echo "  â€¢ Check API key has 'App Manager' or 'Admin' role"
                echo "  â€¢ Ensure API key hasn't been revoked"
              elif grep -q "network" "$LOG_FILE" || grep -q "timed out" "$LOG_FILE"; then
                echo ""
                echo "ðŸ” Network error detected - will retry"
              elif grep -q "Package already exists" "$LOG_FILE"; then
                echo ""
                echo "ðŸ” Package version already exists in App Store Connect"
                echo "This may be expected if re-running the workflow"
                UPLOAD_SUCCESS=true  # Don't fail on duplicate upload
              elif grep -q "Invalid package" "$LOG_FILE" || grep -q "not valid" "$LOG_FILE"; then
                echo ""
                echo "ðŸ” Invalid package error detected"
                echo "Troubleshooting:"
                echo "  â€¢ Check package is properly signed"
                echo "  â€¢ Verify bundle ID matches App Store Connect: com.clidey.whodb"
                echo "  â€¢ Ensure app is signed with '3rd Party Mac Developer' certificate"
                break  # Don't retry on validation errors
              fi

              if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                echo "Will retry in 10 seconds..."
              fi
            fi

            ATTEMPT=$((ATTEMPT + 1))
          done

          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"

          if [ "$UPLOAD_SUCCESS" = "false" ]; then
            echo ""
            echo "âŒ Upload failed after $MAX_ATTEMPTS attempts"
            echo ""
            echo "ðŸ“‹ Log files:"
            for i in $(seq 1 $((ATTEMPT - 1))); do
              LOG="/tmp/transporter_upload_attempt_${i}.log"
              if [ -f "$LOG" ]; then
                echo "  Attempt $i: $LOG"
              fi
            done
            echo ""
            echo "ðŸ”— Helpful resources:"
            echo "  â€¢ App Store Connect: https://appstoreconnect.apple.com"
            echo "  â€¢ Upload guide: https://developer.apple.com/help/app-store-connect/manage-builds/upload-builds"
            exit 1
          fi

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  Upload Complete"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "ðŸ” IMPORTANT: Verify upload in App Store Connect"
          echo ""
          echo "Even though the upload reported success, please verify:"
          echo "  1. Go to https://appstoreconnect.apple.com/apps"
          echo "  2. Click on 'WhoDB'"
          echo "  3. Go to 'TestFlight' or 'App Store' tab"
          echo "  4. Look for build version ${{ inputs.version }}"
          echo ""
          echo "â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€"
          echo ""
          echo "ðŸ“ Next steps:"
          echo ""
          if [ "${{ inputs.stage-only }}" = "true" ]; then
            echo "1ï¸âƒ£  Wait for App Store Connect to process the build"
            echo "    â±ï¸  Usually takes 5-10 minutes"
            echo "    ðŸ“Š Status: Processing â†’ Ready to Submit"
            echo ""
            echo "2ï¸âƒ£  Once status shows 'Ready to Submit':"
            echo "    â€¢ Configure TestFlight testing if needed"
            echo "    â€¢ Add internal/external testers"
            echo "    â€¢ Or submit directly for App Store review"
            echo ""
            echo "3ï¸âƒ£  Monitor processing:"
            echo "    ðŸ”— https://appstoreconnect.apple.com/apps"
          else
            echo "âž¡ï¸  Next: Automated submission for App Store review..."
            echo "    The workflow will now wait for the build to process"
            echo "    and automatically submit for review."
          fi
          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "âœ… Upload complete!"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"

      - name: Submit for App Store Review
        if: steps.check_creds.outputs.has_creds == 'true' && inputs.stage-only != true
        env:
          APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          set -e

          VERSION="${{ inputs.version }}"
          # Strip 'v' prefix if present for build number
          BUILD_NUMBER="${VERSION#v}"
          BUNDLE_ID="com.clidey.whodb"

          # Prepare release notes - use input or default message
          RELEASE_NOTES="${{ inputs.release-notes }}"
          if [ -z "$RELEASE_NOTES" ]; then
            RELEASE_NOTES="Bug fixes and performance improvements."
          fi

          echo ""
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo "  Submitting for App Store Review"
          echo "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•"
          echo ""
          echo "Version: $VERSION"
          echo "Build: $BUILD_NUMBER"
          echo ""

          # Run the submission script
          chmod +x .github/scripts/appstore-connect.sh
          .github/scripts/appstore-connect.sh submit-version \
            "$BUNDLE_ID" \
            "$BUILD_NUMBER" \
            "$BUILD_NUMBER" \
            "$RELEASE_NOTES"

      - name: Clean up API key
        if: always() && steps.check_creds.outputs.has_creds == 'true'
        run: |
          rm -rf ~/.appstoreconnect/private_keys
          echo "ðŸ§¹ API key cleaned up"

      - name: Summary
        if: always()
        run: |
          echo "## Apple App Store Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.check_creds.outputs.has_creds }}" = "false" ]; then
            echo "â­ï¸ **Status:** Skipped (no credentials)" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ inputs.stage-only }}" = "true" ]; then
            echo "ðŸ“¦ **Status:** TestFlight upload completed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Package is available for TestFlight testing." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "**Next steps:**" >> $GITHUB_STEP_SUMMARY
            echo "- Wait for build processing to complete" >> $GITHUB_STEP_SUMMARY
            echo "- Add testers in TestFlight" >> $GITHUB_STEP_SUMMARY
            echo "- Submit for App Store review when ready" >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸš€ **Status:** Submitted for App Store review" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "The app has been automatically submitted for review." >> $GITHUB_STEP_SUMMARY
            echo "Apple typically reviews apps within 24-48 hours." >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Monitor status: [App Store Connect](https://appstoreconnect.apple.com/apps)" >> $GITHUB_STEP_SUMMARY
          fi