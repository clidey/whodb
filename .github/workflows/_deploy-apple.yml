name: Deploy to Apple App Store

on:
  workflow_call:
    inputs:
      version:
        description: 'Version being deployed'
        required: true
        type: string
      stage-only:
        description: 'Stage only mode (TestFlight only)'
        required: false
        type: boolean
        default: false
    secrets:
      APPLE_CERTIFICATES_P12:
        required: false
      APPLE_CERTIFICATES_PASSWORD:
        required: false
      KEYCHAIN_PASSWORD:
        required: false
      APP_STORE_CONNECT_API_KEY:
        required: false
      APP_STORE_CONNECT_API_KEY_ID:
        required: false
      APP_STORE_CONNECT_ISSUER_ID:
        required: false
      APPLE_DEVELOPER_ID:
        required: false
      APPLE_DEVELOPER_TEAM_ID:
        required: false

jobs:
  package-mac-app-store:
    name: Package for Mac App Store
    runs-on: macos-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download macOS DMG
        uses: actions/download-artifact@v4
        with:
          name: desktop-darwin-dmg
          path: desktop-builds/

      - name: Download macOS App Bundle
        uses: actions/download-artifact@v4
        with:
          name: desktop-darwin-app
          path: desktop-builds/

      - name: Check for app bundle
        id: check_app
        run: |
          # Look for the app bundle
          APP_PATHS=(
            "desktop-builds/build/darwin/universal/whodb.app"
            "desktop-builds/darwin/universal/whodb.app"
            "desktop-builds/whodb.app"
          )

          APP_PATH=""
          for path in "${APP_PATHS[@]}"; do
            if [ -d "$path" ]; then
              APP_PATH="$path"
              echo "âœ… Found app bundle at: $APP_PATH"
              break
            fi
          done

          if [ -z "$APP_PATH" ]; then
            echo "âŒ App bundle not found"
            exit 1
          fi

          echo "app_path=$APP_PATH" >> $GITHUB_OUTPUT

      - name: Import Apple Developer Certificates
        env:
          CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_CERTIFICATES_P12 }}
          CERTIFICATE_PASSWORD: ${{ secrets.APPLE_CERTIFICATES_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          if [ -z "$CERTIFICATE_P12_BASE64" ]; then
            echo "âŒ ERROR: Apple certificates are required for Mac App Store packaging"
            echo "Please configure APPLE_CERTIFICATES_P12 and APPLE_CERTIFICATES_PASSWORD secrets"
            exit 1
          fi

          if [ -z "$CERTIFICATE_PASSWORD" ]; then
            echo "âŒ ERROR: APPLE_CERTIFICATES_PASSWORD is required"
            exit 1
          fi

          echo "ðŸ” Setting up keychain for code signing..."

          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          KEYCHAIN_PASSWORD_VALUE="${KEYCHAIN_PASSWORD:-$(uuidgen)}"

          # Decode certificate
          echo "$CERTIFICATE_P12_BASE64" | base64 --decode -o "$CERTIFICATE_PATH"

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD_VALUE" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD_VALUE" "$KEYCHAIN_PATH"

          # Import certificate to keychain
          security import "$CERTIFICATE_PATH" -P "$CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"

          # Set keychain search list
          security list-keychain -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | sed s/\"//g)

          # Allow codesign to access keychain
          security set-key-partition-list -S apple-tool:,apple:,codesign: \
            -s -k "$KEYCHAIN_PASSWORD_VALUE" "$KEYCHAIN_PATH"

          echo "âœ… Certificates imported successfully"

          # List available signing identities for verification
          echo "Available codesigning identities:"
          security find-identity -v -p codesigning "$KEYCHAIN_PATH"

          echo ""
          echo "Available basic identities (includes installer certs):"
          security find-identity -v -p basic "$KEYCHAIN_PATH"

          echo ""
          echo "All identities in keychain:"
          security find-identity -v "$KEYCHAIN_PATH"

      - name: Prepare Mac App Store package
        env:
          APPLE_DEVELOPER_ID: ${{ secrets.APPLE_DEVELOPER_ID }}
          APPLE_DEVELOPER_TEAM_ID: ${{ secrets.APPLE_DEVELOPER_TEAM_ID }}
        run: |
          echo "ðŸ“¦ Preparing Mac App Store package..."

          # Validate required credentials
          if [ -z "$APPLE_DEVELOPER_ID" ] || [ -z "$APPLE_DEVELOPER_TEAM_ID" ]; then
            echo "âŒ ERROR: APPLE_DEVELOPER_ID and APPLE_DEVELOPER_TEAM_ID are required"
            exit 1
          fi

          APP_PATH="${{ steps.check_app.outputs.app_path }}"
          PKG_PATH="WhoDB_${{ inputs.version }}.pkg"

          echo "ðŸ” Creating signed PKG installer..."

          # Sign the app bundle first if not already signed
          codesign --force --deep --sign "$APPLE_DEVELOPER_ID" \
            --options runtime --timestamp \
            "$APP_PATH"

          # Create signed PKG installer
          productbuild --component "$APP_PATH" /Applications \
            --sign "$APPLE_DEVELOPER_ID" \
            --identifier "com.clidey.whodb" \
            --version "${{ inputs.version }}" \
            "$PKG_PATH"

          echo "âœ… Signed PKG created"

          # Verify package
          if [ -f "$PKG_PATH" ]; then
            echo "Package size: $(du -h "$PKG_PATH" | cut -f1)"
            pkgutil --check-signature "$PKG_PATH"
          else
            echo "âŒ Failed to create PKG"
            exit 1
          fi

      - name: Upload Mac App Store package
        uses: actions/upload-artifact@v4
        with:
          name: mac-app-store-package
          path: "*.pkg"
          retention-days: 1

      - name: Cleanup Keychain
        if: always()
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/app-signing.keychain-db
          if [ -f "$KEYCHAIN_PATH" ]; then
            echo "ðŸ§¹ Cleaning up keychain..."
            security delete-keychain "$KEYCHAIN_PATH" || true
            echo "âœ… Keychain cleanup complete"
          fi

  deploy-apple-store:
    name: Submit to Apple App Store
    runs-on: macos-latest
    needs: [ package-mac-app-store ]
    continue-on-error: ${{ inputs.stage-only }}
    steps:
      - name: Checkout for scripts
        uses: actions/checkout@v4

      - name: Check Apple Store credentials
        id: check_creds
        run: |
          echo "ðŸ” Checking Apple Store credentials..."

          if [ -z "${{ secrets.APP_STORE_CONNECT_API_KEY }}" ] || \
             [ -z "${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}" ] || \
             [ -z "${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}" ]; then
            echo "âŒ ERROR: App Store Connect API credentials are required"
            echo "Please configure APP_STORE_CONNECT_API_KEY, APP_STORE_CONNECT_API_KEY_ID, and APP_STORE_CONNECT_ISSUER_ID secrets"
            exit 1
          fi

          echo "âœ… All App Store Connect API credentials configured"
          echo "has_creds=true" >> $GITHUB_OUTPUT

      - name: Download Mac App Store package
        if: steps.check_creds.outputs.has_creds == 'true'
        uses: actions/download-artifact@v4
        with:
          name: mac-app-store-package
          path: .

      - name: Setup App Store Connect API key
        if: steps.check_creds.outputs.has_creds == 'true'
        env:
          APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          echo "ðŸ“ Setting up App Store Connect API key..."

          # Create private keys directory
          mkdir -p ~/.appstoreconnect/private_keys

          # Write the API key to file
          echo "$APP_STORE_CONNECT_API_KEY" > ~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8

          # Set proper permissions
          chmod 600 ~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8

          echo "âœ… API key configured"

      - name: Upload to App Store Connect
        if: steps.check_creds.outputs.has_creds == 'true'
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          PKG_FILE=$(ls *.pkg | head -1)

          if [ -z "$PKG_FILE" ]; then
            echo "âŒ No PKG file found"
            exit 1
          fi

          echo "ðŸ“¤ Uploading package: $PKG_FILE"

          if [ "${{ inputs.stage-only }}" = "true" ]; then
            echo "ðŸ“¦ STAGE MODE - Uploading for TestFlight only"

            # Upload for TestFlight testing
            xcrun altool --upload-package "$PKG_FILE" \
              --type macos \
              --apiKey "$APP_STORE_CONNECT_API_KEY_ID" \
              --apiIssuer "$APP_STORE_CONNECT_ISSUER_ID" \
              --verbose

            if [ $? -eq 0 ]; then
              echo "âœ… Package uploaded for TestFlight distribution"
              echo ""
              echo "ðŸ“ Next steps:"
              echo "  1. Wait for processing to complete (usually 5-10 minutes)"
              echo "  2. Configure TestFlight testing in App Store Connect"
              echo "  3. Submit for App Store review when ready"
            else
              echo "âŒ Upload failed"
              exit 1
            fi
          else
            echo "ðŸš€ PRODUCTION MODE - Submitting for App Store review"

            # Upload and submit for App Store review
            xcrun altool --upload-package "$PKG_FILE" \
              --type macos \
              --apiKey "$APP_STORE_CONNECT_API_KEY_ID" \
              --apiIssuer "$APP_STORE_CONNECT_ISSUER_ID" \
              --auto-submit \
              --verbose

            if [ $? -eq 0 ]; then
              echo "âœ… Package uploaded and submitted for App Store review"
              echo ""
              echo "ðŸ“ Next steps:"
              echo "  1. Monitor review status in App Store Connect"
              echo "  2. Respond to any reviewer feedback"
              echo "  3. Release when approved"
            else
              echo "âŒ Upload/submission failed"
              exit 1
            fi
          fi

      - name: Clean up API key
        if: always() && steps.check_creds.outputs.has_creds == 'true'
        run: |
          rm -rf ~/.appstoreconnect/private_keys
          echo "ðŸ§¹ API key cleaned up"

      - name: Summary
        if: always()
        run: |
          echo "## Apple App Store Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.check_creds.outputs.has_creds }}" = "false" ]; then
            echo "â­ï¸ **Status:** Skipped (no credentials)" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ inputs.stage-only }}" = "true" ]; then
            echo "ðŸ“¦ **Status:** TestFlight upload completed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Package is available for TestFlight testing." >> $GITHUB_STEP_SUMMARY
          else
            echo "ðŸš€ **Status:** Submitted for App Store review" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Monitor review status in App Store Connect." >> $GITHUB_STEP_SUMMARY
          fi