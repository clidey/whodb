name: Deploy to Apple App Store

on:
  workflow_call:
    inputs:
      version:
        description: 'Version being deployed'
        required: true
        type: string
      stage-only:
        description: 'Stage only mode (TestFlight only)'
        required: false
        type: boolean
        default: false
    secrets:
      APPLE_CERTIFICATES_P12:
        required: false
      APPLE_CERTIFICATES_PASSWORD:
        required: false
      KEYCHAIN_PASSWORD:
        required: false
      APPLE_MAS_CERTIFICATES_P12:
        required: false
      APPLE_MAS_CERTIFICATES_PASSWORD:
        required: false
      APPLE_MAS_CERT_APPLICATION:
        required: false
      APPLE_MAS_CERT_INSTALLER:
        required: false
      APPLE_MAS_PROVISIONING_PROFILE:
        required: false
      APP_STORE_CONNECT_API_KEY:
        required: false
      APP_STORE_CONNECT_API_KEY_ID:
        required: false
      APP_STORE_CONNECT_ISSUER_ID:
        required: false
      APPLE_DEVELOPER_ID:
        required: false
      APPLE_DEVELOPER_TEAM_ID:
        required: false
      APPLE_APP_ID:
        required: false
      ASC_PUBLIC_ID:
        required: false

jobs:
  package-mac-app-store:
    name: Package for Mac App Store
    runs-on: macos-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download macOS DMG
        uses: actions/download-artifact@v4
        with:
          name: desktop-darwin-dmg
          path: desktop-builds/

      - name: Download macOS App Bundle (MAS)
        uses: actions/download-artifact@v4
        with:
          name: desktop-darwin-mas-app
          path: desktop-builds/

      # No need to download entitlements - the app is already signed with them

      - name: Generate Homebrew cask
        run: |
          VERSION="${{ inputs.version }}"

          # Find DMG file
          DMG_PATH=$(find desktop-builds -name "*.dmg" | head -1)

          if [ -z "$DMG_PATH" ]; then
            echo "‚ö†Ô∏è  No DMG file found, skipping Homebrew cask generation"
            exit 0
          fi

          # Generate cask using script
          .github/scripts/generate-homebrew-cask.sh "$VERSION" "$DMG_PATH" whodb.rb

          # Create usage instructions
          cat > HOMEBREW_TESTING.md <<EOF
          # Local Homebrew Cask Testing

          This cask file was generated for WhoDB v${VERSION}.

          ## Local Testing Instructions:

          1. Download the whodb.rb file from this workflow run
          2. Install locally:
             \`\`\`bash
             brew install --cask whodb.rb
             \`\`\`

          3. Test the app:
             \`\`\`bash
             open -a WhoDB
             \`\`\`

          4. Uninstall when done:
             \`\`\`bash
             brew uninstall --cask whodb
             \`\`\`

          ## Submit to Homebrew (after production release):

          1. Fork homebrew-cask repository
          2. Create branch: \`update-whodb-${VERSION}\`
          3. Add/update \`Casks/w/whodb.rb\` with this file
          4. Submit PR with title: \`whodb ${VERSION}\` (or \`whodb ${VERSION} (new cask)\` if first submission)
          EOF

          echo ""
          echo "üìã Testing instructions created"

      - name: Upload Homebrew cask
        uses: actions/upload-artifact@v4
        with:
          name: homebrew-cask-apple
          path: |
            whodb.rb
            HOMEBREW_TESTING.md
          retention-days: 30

      - name: Check for MAS app bundle
        id: check_app
        run: |
          # Look for the MAS app bundle (should be WhoDB.app with proper case)
          APP_PATHS=(
            "desktop-builds/WhoDB.app"
            "desktop-builds/build/darwin/universal/WhoDB.app"
            "desktop-builds/darwin/universal/WhoDB.app"
          )

          APP_PATH=""
          for path in "${APP_PATHS[@]}"; do
            if [ -d "$path" ]; then
              APP_PATH="$path"
              echo "‚úÖ Found MAS app bundle at: $APP_PATH"
              break
            fi
          done

          if [ -z "$APP_PATH" ]; then
            echo "‚ùå MAS app bundle not found"
            echo "Available files:"
            find desktop-builds -name "*.app" -type d || true
            exit 1
          fi

          echo "app_path=$APP_PATH" >> $GITHUB_OUTPUT

      - name: Import Mac App Store Installer Certificate
        env:
          MAS_CERTIFICATE_P12_BASE64: ${{ secrets.APPLE_MAS_CERTIFICATES_P12 }}
          MAS_CERTIFICATE_PASSWORD: ${{ secrets.APPLE_MAS_CERTIFICATES_PASSWORD }}
          KEYCHAIN_PASSWORD: ${{ secrets.KEYCHAIN_PASSWORD }}
        run: |
          if [ -z "$MAS_CERTIFICATE_P12_BASE64" ]; then
            echo "‚ùå ERROR: Mac App Store certificates are required for PKG signing"
            echo "Please configure APPLE_MAS_CERTIFICATES_P12 and APPLE_MAS_CERTIFICATES_PASSWORD secrets"
            exit 1
          fi

          if [ -z "$MAS_CERTIFICATE_PASSWORD" ]; then
            echo "‚ùå ERROR: APPLE_MAS_CERTIFICATES_PASSWORD is required"
            exit 1
          fi

          echo "üîê Setting up keychain for Mac App Store PKG signing..."

          # Create variables
          CERTIFICATE_PATH=$RUNNER_TEMP/mas_certificate.p12
          KEYCHAIN_PATH=$RUNNER_TEMP/mas-signing.keychain-db
          KEYCHAIN_PASSWORD_VALUE="${KEYCHAIN_PASSWORD:-$(uuidgen)}"

          # Decode certificate
          echo "$MAS_CERTIFICATE_P12_BASE64" | base64 --decode -o "$CERTIFICATE_PATH"

          # Create temporary keychain
          security create-keychain -p "$KEYCHAIN_PASSWORD_VALUE" "$KEYCHAIN_PATH"
          security set-keychain-settings -lut 21600 "$KEYCHAIN_PATH"
          security unlock-keychain -p "$KEYCHAIN_PASSWORD_VALUE" "$KEYCHAIN_PATH"

          # Import certificate to keychain
          security import "$CERTIFICATE_PATH" -P "$MAS_CERTIFICATE_PASSWORD" \
            -A -t cert -f pkcs12 -k "$KEYCHAIN_PATH"

          # Set keychain search list
          security list-keychain -d user -s "$KEYCHAIN_PATH" $(security list-keychains -d user | sed s/\"//g)

          # Allow productbuild to access keychain
          security set-key-partition-list -S apple-tool:,apple:,productbuild: \
            -s -k "$KEYCHAIN_PASSWORD_VALUE" "$KEYCHAIN_PATH"

          echo "‚úÖ Mac App Store installer certificate imported successfully"

          # List available signing identities for verification
          echo "Available certificates in keychain:"
          security find-identity -v -p basic "$KEYCHAIN_PATH"

          echo ""
          echo "Looking for installer certificate..."
          # Check if we have the installer cert (don't fail if not found)
          if security find-identity -v -p basic "$KEYCHAIN_PATH" | grep -q "Mac Installer Distribution\|3rd Party Mac Developer Installer"; then
            INSTALLER_CERT=$(security find-identity -v -p basic "$KEYCHAIN_PATH" | grep "Mac Installer Distribution\|3rd Party Mac Developer Installer" | head -1 | awk '{print $2}')
            echo "Found installer certificate: $INSTALLER_CERT"
          else
            echo "‚ö†Ô∏è  No Mac Installer Distribution certificate found"
            echo "Available certificates:"
            security find-identity -v "$KEYCHAIN_PATH"
          fi

      - name: Package Mac App Store build
        env:
          MAS_CERT_INSTALLER: ${{ secrets.APPLE_MAS_CERT_INSTALLER }}
        run: |
          echo "üì¶ Packaging Mac App Store build..."

          # Validate installer certificate
          if [ -z "$MAS_CERT_INSTALLER" ]; then
            echo "‚ùå ERROR: APPLE_MAS_CERT_INSTALLER is required"
            exit 1
          fi

          # Find the already-signed MAS app
          APP_PATH="${{ steps.check_app.outputs.app_path }}"
          PKG_PATH="WhoDB_${{ inputs.version }}.pkg"

          if [ ! -d "$APP_PATH" ]; then
            echo "‚ùå ERROR: App bundle not found at $APP_PATH"
            exit 1
          fi

          echo "Using pre-signed MAS app: $APP_PATH"

          # CRITICAL FIX: GitHub Actions artifact upload/download loses Unix permissions
          # Restore execute permissions that were set during build
          echo "üîß Restoring execute permissions (lost during artifact transfer)..."
          chmod +x "$APP_PATH/Contents/MacOS/whodb"
          ls -la "$APP_PATH/Contents/MacOS/whodb"

          # Verify the app is already signed correctly
          echo "Verifying existing signature..."
          codesign --verify --verbose=4 "$APP_PATH"
          codesign --display --entitlements - "$APP_PATH"

          # Create signed PKG installer with Mac Installer Distribution certificate
          echo "üîè Creating signed PKG installer..."
          productbuild --component "$APP_PATH" /Applications \
            --sign "$MAS_CERT_INSTALLER" \
            --identifier "com.clidey.whodb" \
            --version "${{ inputs.version }}" \
            "$PKG_PATH"

          echo "‚úÖ Signed PKG created"

          # Verify package
          if [ -f "$PKG_PATH" ]; then
            echo "Package size: $(du -h "$PKG_PATH" | cut -f1)"
            pkgutil --check-signature "$PKG_PATH"
          else
            echo "‚ùå Failed to create PKG"
            exit 1
          fi

      - name: Upload Mac App Store package
        uses: actions/upload-artifact@v4
        with:
          name: mac-app-store-package
          path: "*.pkg"
          retention-days: 1

      - name: Cleanup Keychain
        if: always()
        run: |
          KEYCHAIN_PATH=$RUNNER_TEMP/mas-signing.keychain-db
          if [ -f "$KEYCHAIN_PATH" ]; then
            echo "üßπ Cleaning up Mac App Store keychain..."
            security delete-keychain "$KEYCHAIN_PATH" || true
            echo "‚úÖ Keychain cleanup complete"
          fi

  deploy-apple-store:
    name: Submit to Apple App Store
    runs-on: macos-latest
    needs: [ package-mac-app-store ]
    continue-on-error: ${{ inputs.stage-only }}
    steps:
      - name: Checkout for scripts
        uses: actions/checkout@v4

      - name: Check Apple Store credentials
        id: check_creds
        run: |
          echo "üîç Checking Apple Store credentials..."

          if [ -z "${{ secrets.APP_STORE_CONNECT_API_KEY }}" ] || \
             [ -z "${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}" ] || \
             [ -z "${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}" ]; then
            echo "‚ùå ERROR: App Store Connect API credentials are required"
            echo "Please configure APP_STORE_CONNECT_API_KEY, APP_STORE_CONNECT_API_KEY_ID, and APP_STORE_CONNECT_ISSUER_ID secrets"
            exit 1
          fi

          echo "‚úÖ All App Store Connect API credentials configured"
          echo "has_creds=true" >> $GITHUB_OUTPUT

      - name: Download Mac App Store package
        if: steps.check_creds.outputs.has_creds == 'true'
        uses: actions/download-artifact@v4
        with:
          name: mac-app-store-package
          path: .

      - name: Setup App Store Connect API key
        if: steps.check_creds.outputs.has_creds == 'true'
        env:
          APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          echo "üìù Setting up App Store Connect API key..."

          # Create private keys directory
          mkdir -p ~/.appstoreconnect/private_keys

          # Write the API key to file
          echo "$APP_STORE_CONNECT_API_KEY" > ~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8

          # Set proper permissions
          chmod 600 ~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8

          echo "‚úÖ API key configured"

      - name: Upload to App Store Connect
        if: steps.check_creds.outputs.has_creds == 'true'
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          set -e  # Exit on any error

          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "  App Store Connect Upload"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

          # Find PKG file
          PKG_FILE=$(ls *.pkg 2>/dev/null | head -1)

          if [ -z "$PKG_FILE" ]; then
            echo "‚ùå ERROR: No PKG file found in current directory"
            echo "üìÅ Directory contents:"
            ls -lh
            exit 1
          fi

          echo "üì¶ Package: $PKG_FILE"
          echo "üìä Size: $(du -h "$PKG_FILE" | cut -f1)"
          echo "üîê Authentication: API Key (JWT)"

          if [ "${{ inputs.stage-only }}" = "true" ]; then
            echo "üéØ Mode: STAGE (TestFlight only)"
          else
            echo "üéØ Mode: PRODUCTION (App Store)"
          fi
          echo ""

          # Try multiple upload methods
          echo "üîç Determining upload method..."

          # Method 1: Try finding iTMSTransporter in SharedFrameworks (preferred location)
          TRANSPORTER_PATH="/Applications/Xcode.app/Contents/SharedFrameworks/ContentDeliveryServices.framework/itms/bin/iTMSTransporter"

          # Check all Xcode versions on the system
          if [ ! -f "$TRANSPORTER_PATH" ]; then
            for XCODE_PATH in /Applications/Xcode*.app; do
              TEST_PATH="$XCODE_PATH/Contents/SharedFrameworks/ContentDeliveryServices.framework/itms/bin/iTMSTransporter"
              if [ -f "$TEST_PATH" ]; then
                TRANSPORTER_PATH="$TEST_PATH"
                break
              fi
            done
          fi

          UPLOAD_METHOD=""

          if [ -f "$TRANSPORTER_PATH" ]; then
            echo "‚úÖ Found iTMSTransporter: $TRANSPORTER_PATH"
            UPLOAD_METHOD="transporter"
          else
            echo "‚ö†Ô∏è  iTMSTransporter not found in SharedFrameworks"
            echo "üîÑ Falling back to xcrun altool (package uploads still supported)"
            UPLOAD_METHOD="altool"
          fi
          echo ""

          # Verify API key
          API_KEY_PATH="$HOME/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8"

          if [ ! -f "$API_KEY_PATH" ]; then
            echo "‚ùå ERROR: API key not found at $API_KEY_PATH"
            echo ""
            echo "Troubleshooting:"
            echo "  ‚Ä¢ Verify APP_STORE_CONNECT_API_KEY secret is configured"
            echo "  ‚Ä¢ Check 'Setup App Store Connect API key' step completed successfully"
            exit 1
          fi

          echo "‚úÖ API key found and configured"
          echo ""

          # Validate PKG signature before upload
          echo "üîç Validating package signature..."
          if pkgutil --check-signature "$PKG_FILE" > /dev/null 2>&1; then
            echo "‚úÖ Package signature valid"
            pkgutil --check-signature "$PKG_FILE" | head -5
          else
            echo "‚ö†Ô∏è  Warning: Could not verify package signature"
          fi
          echo ""

          # Upload with retry logic
          echo "üì§ Starting upload to App Store Connect..."
          echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

          MAX_ATTEMPTS=3
          ATTEMPT=1
          UPLOAD_SUCCESS=false

          while [ $ATTEMPT -le $MAX_ATTEMPTS ] && [ "$UPLOAD_SUCCESS" = "false" ]; do
            if [ $ATTEMPT -gt 1 ]; then
              echo ""
              echo "üîÑ Retry attempt $ATTEMPT of $MAX_ATTEMPTS..."
              sleep 10  # Wait before retry
            else
              echo "‚è≥ Attempt $ATTEMPT of $MAX_ATTEMPTS..."
            fi

            # Create log file for this attempt
            LOG_FILE="/tmp/transporter_upload_attempt_${ATTEMPT}.log"

            # Run upload based on method
            set +e  # Temporarily disable exit on error

            if [ "$UPLOAD_METHOD" = "transporter" ]; then
              echo "Using iTMSTransporter..."
              "$TRANSPORTER_PATH" \
                -m upload \
                -f "$PKG_FILE" \
                -k "$API_KEY_PATH" \
                -i "$APP_STORE_CONNECT_API_KEY_ID" \
                -issuer "$APP_STORE_CONNECT_ISSUER_ID" \
                -v eXtreme \
                2>&1 | tee "$LOG_FILE"
            else
              echo "Using xcrun altool..."
              # Note: altool upload-app is for IPA/PKG uploads (still supported)
              # Only notarization is deprecated
              xcrun altool \
                --upload-app \
                --type macos \
                --file "$PKG_FILE" \
                --apiKey "$APP_STORE_CONNECT_API_KEY_ID" \
                --apiIssuer "$APP_STORE_CONNECT_ISSUER_ID" \
                --verbose \
                2>&1 | tee "$LOG_FILE"
            fi

            UPLOAD_EXIT_CODE=$?
            set -e  # Re-enable exit on error

            # Check both exit code AND log content for actual success
            if [ $UPLOAD_EXIT_CODE -eq 0 ] && ! grep -q "ERROR:" "$LOG_FILE"; then
              # Different success indicators for different methods
              if [ "$UPLOAD_METHOD" = "altool" ]; then
                # altool success indicators
                if grep -q "No errors uploading" "$LOG_FILE" || grep -q "successfully uploaded" "$LOG_FILE"; then
                  UPLOAD_SUCCESS=true
                  echo ""
                  echo "‚úÖ Upload completed successfully!"
                else
                  echo ""
                  echo "‚ö†Ô∏è  altool completed with exit code 0, verifying..."
                  # altool sometimes succeeds without explicit success message
                  if ! grep -q "ERROR" "$LOG_FILE" && ! grep -q "failed" "$LOG_FILE"; then
                    echo "‚úÖ No errors detected, upload appears successful"
                    UPLOAD_SUCCESS=true
                  fi
                fi
              else
                # iTMSTransporter success indicators
                if grep -q "Successfully uploaded" "$LOG_FILE" || grep -q "Package Summary" "$LOG_FILE" || grep -q "No errors uploading" "$LOG_FILE"; then
                  UPLOAD_SUCCESS=true
                  echo ""
                  echo "‚úÖ Upload completed successfully!"
                elif grep -q "OSStatus error" "$LOG_FILE"; then
                  # Exit code 0 but OSStatus error present - this is likely a failure
                  echo ""
                  echo "‚ùå OSStatus error detected - upload failed"
                  echo "The -10814 error indicates iTMSTransporter couldn't complete the upload"

                  # If this was iTMSTransporter, try switching to altool for next attempt
                  if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                    echo "üîÑ Will retry with altool instead"
                    UPLOAD_METHOD="altool"
                  fi
                else
                  # Exit code 0 but no clear success indicators
                  echo ""
                  echo "‚ö†Ô∏è  Upload completed with exit code 0, but no success confirmation found"
                  echo "This likely means upload failed - will retry if attempts remain"
                fi
              fi
            else
              echo ""
              echo "‚ùå Upload failed with exit code: $UPLOAD_EXIT_CODE"

              # Parse log for common errors
              if grep -q "Could not authenticate" "$LOG_FILE"; then
                echo ""
                echo "üîç Authentication error detected"
                echo "Troubleshooting:"
                echo "  ‚Ä¢ Verify API key ID and Issuer ID are correct"
                echo "  ‚Ä¢ Check API key has 'App Manager' or 'Admin' role"
                echo "  ‚Ä¢ Ensure API key hasn't been revoked"
              elif grep -q "network" "$LOG_FILE" || grep -q "timed out" "$LOG_FILE"; then
                echo ""
                echo "üîç Network error detected - will retry"
              elif grep -q "Package already exists" "$LOG_FILE"; then
                echo ""
                echo "üîç Package version already exists in App Store Connect"
                echo "This may be expected if re-running the workflow"
                UPLOAD_SUCCESS=true  # Don't fail on duplicate upload
              elif grep -q "Invalid package" "$LOG_FILE" || grep -q "not valid" "$LOG_FILE"; then
                echo ""
                echo "üîç Invalid package error detected"
                echo "Troubleshooting:"
                echo "  ‚Ä¢ Check package is properly signed"
                echo "  ‚Ä¢ Verify bundle ID matches App Store Connect: com.clidey.whodb"
                echo "  ‚Ä¢ Ensure app is signed with '3rd Party Mac Developer' certificate"
                break  # Don't retry on validation errors
              fi

              if [ $ATTEMPT -lt $MAX_ATTEMPTS ]; then
                echo "Will retry in 10 seconds..."
              fi
            fi

            ATTEMPT=$((ATTEMPT + 1))
          done

          echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"

          if [ "$UPLOAD_SUCCESS" = "false" ]; then
            echo ""
            echo "‚ùå Upload failed after $MAX_ATTEMPTS attempts"
            echo ""
            echo "üìã Log files:"
            for i in $(seq 1 $((ATTEMPT - 1))); do
              LOG="/tmp/transporter_upload_attempt_${i}.log"
              if [ -f "$LOG" ]; then
                echo "  Attempt $i: $LOG"
              fi
            done
            echo ""
            echo "üîó Helpful resources:"
            echo "  ‚Ä¢ App Store Connect: https://appstoreconnect.apple.com"
            echo "  ‚Ä¢ Upload guide: https://developer.apple.com/help/app-store-connect/manage-builds/upload-builds"
            exit 1
          fi

          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "  Upload Complete"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo ""
          echo "üîç IMPORTANT: Verify upload in App Store Connect"
          echo ""
          echo "Even though the upload reported success, please verify:"
          echo "  1. Go to https://appstoreconnect.apple.com/apps"
          echo "  2. Click on 'WhoDB'"
          echo "  3. Go to 'TestFlight' or 'App Store' tab"
          echo "  4. Look for build version ${{ inputs.version }}"
          echo ""
          echo "‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ"
          echo ""
          echo "üìù Next steps:"
          echo ""
          if [ "${{ inputs.stage-only }}" = "true" ]; then
            echo "1Ô∏è‚É£  Wait for App Store Connect to process the build"
            echo "    ‚è±Ô∏è  Usually takes 5-10 minutes"
            echo "    üìä Status: Processing ‚Üí Ready to Submit"
            echo ""
            echo "2Ô∏è‚É£  Once status shows 'Ready to Submit':"
            echo "    ‚Ä¢ Configure TestFlight testing if needed"
            echo "    ‚Ä¢ Add internal/external testers"
            echo "    ‚Ä¢ Or submit directly for App Store review"
            echo ""
            echo "3Ô∏è‚É£  Monitor processing:"
            echo "    üîó https://appstoreconnect.apple.com/apps"
          else
            echo "1Ô∏è‚É£  Build will appear in App Store Connect shortly"
            echo "    üîó https://appstoreconnect.apple.com/apps"
            echo ""
            echo "2Ô∏è‚É£  Wait for 'Ready to Submit' status"
            echo ""
            echo "3Ô∏è‚É£  Complete submission information:"
            echo "    ‚Ä¢ App description"
            echo "    ‚Ä¢ Screenshots"
            echo "    ‚Ä¢ Privacy info"
            echo ""
            echo "4Ô∏è‚É£  Submit for App Store review"
            echo "    ‚è±Ô∏è  Review typically takes 1-3 business days"
          fi
          echo ""
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"
          echo "‚úÖ Workflow complete!"
          echo "‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê"

      - name: Clean up API key
        if: always() && steps.check_creds.outputs.has_creds == 'true'
        run: |
          rm -rf ~/.appstoreconnect/private_keys
          echo "üßπ API key cleaned up"

      - name: Summary
        if: always()
        run: |
          echo "## Apple App Store Deployment Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY

          if [ "${{ steps.check_creds.outputs.has_creds }}" = "false" ]; then
            echo "‚è≠Ô∏è **Status:** Skipped (no credentials)" >> $GITHUB_STEP_SUMMARY
          elif [ "${{ inputs.stage-only }}" = "true" ]; then
            echo "üì¶ **Status:** TestFlight upload completed" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Package is available for TestFlight testing." >> $GITHUB_STEP_SUMMARY
          else
            echo "üöÄ **Status:** Submitted for App Store review" >> $GITHUB_STEP_SUMMARY
            echo "" >> $GITHUB_STEP_SUMMARY
            echo "Monitor review status in App Store Connect." >> $GITHUB_STEP_SUMMARY
          fi