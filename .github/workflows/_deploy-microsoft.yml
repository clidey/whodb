name: Deploy to Microsoft Store

on:
  workflow_call:
    inputs:
      version:
        description: 'Version being deployed'
        required: true
        type: string
      stage-only:
        description: 'Stage only mode (draft submission)'
        required: false
        type: boolean
        default: false
    secrets:
      MS_TENANT_ID:
        required: false
      MS_CLIENT_ID:
        required: false
      MS_CLIENT_SECRET:
        required: false
      MS_APP_ID:
        required: false

jobs:
  package-windows-msix:
    name: Package Windows MSIX
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Windows SDK
        shell: pwsh
        run: |
          Write-Host "Checking for Windows SDK..."
          $ErrorActionPreference = "Continue"

          $makeappxExists = $false
          try {
            $existing = where.exe makeappx.exe 2>$null
            if ($existing) {
              Write-Host "‚úÖ MakeAppx already available at: $existing"
              $makeappxExists = $true
            }
          } catch {}

          if (-not $makeappxExists) {
            $kitsPath = "C:\Program Files (x86)\Windows Kits\10\bin"
            if (Test-Path $kitsPath) {
              $versions = Get-ChildItem -Path $kitsPath -Directory | Where-Object { $_.Name -match "^\d+\.\d+\.\d+\.\d+$" }
              if ($versions) {
                Write-Host "‚úÖ Windows SDK found with versions: $($versions.Name -join ', ')"
                $latestVersion = $versions | Sort-Object Name -Descending | Select-Object -First 1
                $sdkPath = Join-Path $latestVersion.FullName "x64"
                Write-Host "Adding to PATH: $sdkPath"
                if ($env:GITHUB_PATH) {
                  try {
                    Add-Content -Path $env:GITHUB_PATH -Value $sdkPath -ErrorAction Continue
                    Write-Host "‚úÖ Added to GITHUB_PATH"
                  } catch {
                    Write-Host "Note: Could not update GITHUB_PATH, but continuing"
                    $env:PATH = "$sdkPath;$env:PATH"
                  }
                } else {
                  $env:PATH = "$sdkPath;$env:PATH"
                  Write-Host "‚úÖ Added to session PATH"
                }
              } else {
                Write-Host "‚ö†Ô∏è Windows Kits directory exists but no SDK versions found"
              }
            } else {
              Write-Host "‚ö†Ô∏è Windows SDK not found, will search for alternatives during packaging"
            }
          }

          Write-Host "SDK setup completed"
          exit 0

      - name: Download Windows executables
        uses: actions/download-artifact@v4
        with:
          name: desktop-windows-amd64
          path: desktop-builds/

      - name: Create MSIX Package
        shell: pwsh
        run: |
          Write-Host "Creating MSIX package..."
          $msixDir = "msix-package"
          New-Item -ItemType Directory -Force -Path $msixDir

          Write-Host "Looking for Windows executable..."
          Write-Host "Contents of desktop-builds directory:"
          Get-ChildItem -Path "desktop-builds" -Recurse -Filter "*.exe" | ForEach-Object {
            Write-Host "  Found: $($_.FullName)"
          }

          $possiblePaths = @(
            "desktop-builds/windows/amd64/whodb.exe",
            "desktop-builds/build/windows/amd64/whodb.exe",
            "desktop-builds/whodb.exe",
            "desktop-builds/whodb-amd64.exe"
          )

          $exeFound = $false
          foreach ($path in $possiblePaths) {
            if (Test-Path $path) {
              Copy-Item $path "$msixDir/whodb.exe"
              Write-Host "‚úÖ Found and copied executable from: $path"
              $exeFound = $true
              break
            }
          }

          if (-not $exeFound) {
            Write-Error "‚ùå Executable not found in any expected location"
            exit 1
          }

          $manifest = @"
          <?xml version="1.0" encoding="utf-8"?>
          <Package xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
                   xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
                   xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities">
            <Identity Name="WhoDB"
                      Publisher="CN=Clidey"
                      Version="${{ inputs.version }}.0"
                      ProcessorArchitecture="x64" />
            <Properties>
              <DisplayName>WhoDB</DisplayName>
              <PublisherDisplayName>Clidey</PublisherDisplayName>
              <Logo>Assets\StoreLogo.png</Logo>
            </Properties>
            <Dependencies>
              <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.17763.0" MaxVersionTested="10.0.22621.0" />
            </Dependencies>
            <Resources>
              <Resource Language="en-US" />
            </Resources>
            <Applications>
              <Application Id="App" Executable="whodb.exe" EntryPoint="Windows.FullTrustApplication">
                <uap:VisualElements DisplayName="WhoDB"
                                    Description="Database management tool"
                                    BackgroundColor="transparent"
                                    Square150x150Logo="Assets\Square150x150Logo.png"
                                    Square44x44Logo="Assets\Square44x44Logo.png">
                  <uap:DefaultTile Wide310x150Logo="Assets\Wide310x150Logo.png" />
                  <uap:SplashScreen Image="Assets\SplashScreen.png" />
                </uap:VisualElements>
              </Application>
            </Applications>
            <Capabilities>
              <rescap:Capability Name="runFullTrust" />
            </Capabilities>
          </Package>
          "@
          $manifest | Out-File -FilePath "$msixDir/AppxManifest.xml" -Encoding UTF8

          $assetsDir = "$msixDir/Assets"
          New-Item -ItemType Directory -Force -Path $assetsDir

          Add-Type -AssemblyName System.Drawing
          $sizes = @(
            @{Name="StoreLogo.png"; Width=50; Height=50},
            @{Name="Square150x150Logo.png"; Width=150; Height=150},
            @{Name="Square44x44Logo.png"; Width=44; Height=44},
            @{Name="Wide310x150Logo.png"; Width=310; Height=150},
            @{Name="SplashScreen.png"; Width=620; Height=300}
          )

          foreach ($size in $sizes) {
            $bitmap = New-Object System.Drawing.Bitmap $size.Width, $size.Height
            $graphics = [System.Drawing.Graphics]::FromImage($bitmap)
            $graphics.Clear([System.Drawing.Color]::FromArgb(0, 120, 215))
            $graphics.Dispose()
            $bitmap.Save("$assetsDir\$($size.Name)", [System.Drawing.Imaging.ImageFormat]::Png)
            $bitmap.Dispose()
          }

          Write-Host "Searching for MakeAppx.exe..."
          $makeAppx = $null
          try {
            $result = where.exe makeappx.exe 2>$null
            if ($LASTEXITCODE -eq 0 -and $result) {
              $makeAppx = $result | Select-Object -First 1
              Write-Host "Found MakeAppx in PATH: $makeAppx"
            }
          } catch {}

          if (-not $makeAppx) {
            $windowsKitsPath = "C:\Program Files (x86)\Windows Kits\10\bin"
            if (Test-Path $windowsKitsPath) {
              $versionDirs = Get-ChildItem -Path $windowsKitsPath -Directory |
                Where-Object { $_.Name -match "^\d+\.\d+\.\d+\.\d+$" } |
                Sort-Object Name -Descending
              foreach ($versionDir in $versionDirs) {
                $testPath = Join-Path $versionDir.FullName "x64\makeappx.exe"
                if (Test-Path $testPath) {
                  $makeAppx = $testPath
                  break
                }
                $testPath = Join-Path $versionDir.FullName "x86\makeappx.exe"
                if (Test-Path $testPath) {
                  $makeAppx = $testPath
                  break
                }
              }
            }
          }

          if (-not $makeAppx) {
            Write-Host "Creating ZIP package as fallback..."
            $zipPath = "WhoDB_${{ inputs.version }}_windows.zip"
            Compress-Archive -Path $msixDir\* -DestinationPath $zipPath -Force
            if (Test-Path $zipPath) {
              Write-Host "‚ö†Ô∏è Created ZIP package instead of MSIX: $zipPath"
              "This is a fallback ZIP package. MSIX packaging failed." | Out-File "MSIX_FALLBACK.txt"
            } else {
              Write-Error "Failed to create even a ZIP fallback"
              exit 1
            }
          } else {
            Write-Host "Creating MSIX package..."
            $outputPath = "WhoDB_${{ inputs.version }}.msixbundle"
            & $makeAppx pack /d $msixDir /p $outputPath /v
            if ($LASTEXITCODE -ne 0) {
              Write-Error "Failed to create MSIX package"
              exit 1
            }
            Write-Host "‚úÖ MSIX package created: $outputPath"
            Write-Host "File size: $((Get-Item $outputPath).Length / 1MB) MB"
          }

      - name: Upload Windows package
        uses: actions/upload-artifact@v4
        with:
          name: windows-msix
          path: |
            *.msixbundle
            *.zip
            MSIX_FALLBACK.txt
          retention-days: 1

  deploy-microsoft-store:
    name: Submit to Microsoft Store
    runs-on: windows-latest
    needs: [ package-windows-msix ]
    continue-on-error: ${{ inputs.stage-only }}
    steps:
      - name: Checkout for scripts
        uses: actions/checkout@v4

      - name: Check Microsoft Store credentials
        id: check_creds
        shell: pwsh
        run: |
          $hasAllCreds = ("${{ secrets.MS_TENANT_ID }}" -ne "") -and
                        ("${{ secrets.MS_CLIENT_ID }}" -ne "") -and
                        ("${{ secrets.MS_CLIENT_SECRET }}" -ne "") -and
                        ("${{ secrets.MS_APP_ID }}" -ne "")

          if ($hasAllCreds) {
            Write-Host "‚úÖ All Microsoft Store credentials are configured"
            echo "has_creds=true" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "‚ö†Ô∏è Microsoft Store credentials missing"
            if ("${{ inputs.stage-only }}" -eq "true") {
              Write-Host "Continuing in stage-only mode without credentials"
              echo "has_creds=false" >> $env:GITHUB_OUTPUT
            } else {
              Write-Error "Production deployment requires all Microsoft Store credentials"
              exit 1
            }
          }

      - name: Download MSIX package
        if: steps.check_creds.outputs.has_creds == 'true'
        uses: actions/download-artifact@v4
        with:
          name: windows-msix
          path: .

      - name: Setup StoreBroker Module
        if: steps.check_creds.outputs.has_creds == 'true'
        shell: pwsh
        run: |
          Write-Host "Checking for StoreBroker module..."
          if (!(Get-Module -ListAvailable -Name StoreBroker)) {
            Write-Host "Installing StoreBroker module..."
            Install-Module -Name StoreBroker -Force -Scope CurrentUser -AllowClobber
          } else {
            Write-Host "StoreBroker module already installed"
          }
          Write-Host "‚úÖ StoreBroker module ready"

      - name: Submit to Microsoft Store
        if: steps.check_creds.outputs.has_creds == 'true'
        shell: pwsh
        env:
          MS_TENANT_ID: ${{ secrets.MS_TENANT_ID }}
          MS_CLIENT_ID: ${{ secrets.MS_CLIENT_ID }}
          MS_CLIENT_SECRET: ${{ secrets.MS_CLIENT_SECRET }}
          MS_APP_ID: ${{ secrets.MS_APP_ID }}
        run: |
          Import-Module StoreBroker -Force
          $global:SBDisableTelemetry = $true

          Write-Host "Authenticating with Microsoft Partner Center..."
          $securePassword = ConvertTo-SecureString $env:MS_CLIENT_SECRET -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential($env:MS_CLIENT_ID, $securePassword)

          try {
            Set-StoreBrokerAuthentication -TenantId $env:MS_TENANT_ID -Credential $credential
            Write-Host "‚úÖ Successfully authenticated to Microsoft Partner Center"
          } catch {
            Write-Error "Failed to authenticate to Microsoft Partner Center: $_"
            Write-Host "Please ensure your MS_TENANT_ID, MS_CLIENT_ID, and MS_CLIENT_SECRET are correct"
            Write-Host "See: https://github.com/microsoft/StoreBroker/blob/master/Documentation/SETUP.md"
            exit 1
          }

          $appId = $env:MS_APP_ID
          $msixPath = Get-ChildItem -Path "." -Filter "*.msixbundle" | Select-Object -First 1

          if ($null -eq $msixPath) {
            Write-Error "No MSIX bundle found"
            exit 1
          }

          Write-Host "Found MSIX: $($msixPath.Name)"
          Write-Host "App ID: $appId"

          # Check for existing pending submission and delete if needed
          Write-Host "Checking for existing pending submission..."
          try {
            $existingSubmission = Get-ApplicationSubmission -AppId $appId -SubmissionId PendingSubmission
            if ($existingSubmission) {
              Write-Host "Deleting existing pending submission..."
              Remove-ApplicationSubmission -AppId $appId -SubmissionId $existingSubmission.id -Force
            }
          } catch {
            Write-Host "No existing pending submission"
          }

          # Determine submission mode
          if ("${{ inputs.stage-only }}" -eq "true") {
            Write-Host "üì¶ STAGE MODE - Creating draft submission"
            $autoCommit = $false
            $targetPublishMode = "Manual"
          } else {
            Write-Host "üöÄ PRODUCTION MODE - Creating live submission"
            $autoCommit = $true
            $targetPublishMode = "Immediate"
          }

          Write-Host "Creating fresh submission..."
          $newSubmission = New-ApplicationSubmission -AppId $appId

          Write-Host "Fetching last published submission to copy metadata..."
          $app = Get-Application -AppId $appId
          $publishedSubmissionId = $app.lastPublishedApplicationSubmission.id
          $publishedSubmission = Get-ApplicationSubmission -AppId $appId -SubmissionId $publishedSubmissionId

          # Copy over metadata so store details remain intact
          $newSubmission.listings = $publishedSubmission.listings
          $newSubmission.pricing = $publishedSubmission.pricing
          $newSubmission.visibility = $publishedSubmission.visibility
          $newSubmission.hardwarePreferences = $publishedSubmission.hardwarePreferences
          $newSubmission.appProperties = $publishedSubmission.appProperties

          # Replace only the packages
          $newSubmission.applicationPackages = @(@{
              fileName = $msixPath.Name
              fileStatus = "PendingUpload"
              minimumDirectXVersion = "None"
              minimumSystemRam = "None"
          })

          $newSubmission.targetPublishMode = $targetPublishMode

          # Save config to JSON
          $configPath = "storebroker_config.json"
          $newSubmission | ConvertTo-Json -Depth 10 | Out-File $configPath -Encoding UTF8

          try {
            Write-Host "Uploading and submitting new package..."
            Update-ApplicationSubmission `
              -AppId $appId `
              -SubmissionDataPath $configPath `
              -PackagePath $msixPath.FullName `
              -ReplacePackages `
              -AutoCommit:$autoCommit `
              -NoStatus
            if ($autoCommit) {
              Write-Host "‚úÖ Submission created and sent for certification"
            } else {
              Write-Host "‚úÖ Draft submission created successfully"
              Write-Host "Please review and submit manually in Partner Center"
            }
          } catch {
            Write-Error "Failed to create/update submission: $_"
            Write-Host "Error details: $($_.Exception.Message)"
            Write-Host "Stack trace: $($_.ScriptStackTrace)"
            if ("${{ inputs.stage-only }}" -ne "true") {
              exit 1
            }
          }

      - name: Summary
        if: always()
        shell: pwsh
        run: |
          if ("${{ steps.check_creds.outputs.has_creds }}" -eq "false") {
            Write-Host "‚è≠Ô∏è Microsoft Store deployment skipped (no credentials)"
          } elseif ("${{ inputs.stage-only }}" -eq "true") {
            Write-Host "üì¶ Draft submission created in Partner Center"
          } else {
            Write-Host "üöÄ Production submission completed"
          }
