name: Deploy to Microsoft Store

on:
  workflow_call:
    inputs:
      version:
        description: 'Version being deployed'
        required: true
        type: string
      stage-only:
        description: 'Stage only mode (draft submission)'
        required: false
        type: boolean
        default: false
    secrets:
      MS_TENANT_ID:
        required: false
      MS_CLIENT_ID:
        required: false
      MS_CLIENT_SECRET:
        required: false
      MS_APP_ID:
        required: false

jobs:
  package-windows-msix:
    name: Package Windows MSIX
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Windows SDK
        shell: pwsh
        run: |
          Write-Host "Checking for Windows SDK..."
          $ErrorActionPreference = "Continue"

          $makeappxExists = $false
          try {
            $existing = where.exe makeappx.exe 2>$null
            if ($existing) {
              Write-Host "‚úÖ MakeAppx already available at: $existing"
              $makeappxExists = $true
            }
          } catch {}

          if (-not $makeappxExists) {
            $kitsPath = "C:\Program Files (x86)\Windows Kits\10\bin"
            if (Test-Path $kitsPath) {
              $versions = Get-ChildItem -Path $kitsPath -Directory | Where-Object { $_.Name -match "^\d+\.\d+\.\d+\.\d+$" }
              if ($versions) {
                $latestVersion = $versions | Sort-Object Name -Descending | Select-Object -First 1
                $sdkPath = Join-Path $latestVersion.FullName "x64"
                if ($env:GITHUB_PATH) {
                  Add-Content -Path $env:GITHUB_PATH -Value $sdkPath -ErrorAction Continue
                } else {
                  $env:PATH = "$sdkPath;$env:PATH"
                }
              }
            }
          }
          Write-Host "SDK setup completed"
          exit 0

      - name: Download Windows executables
        uses: actions/download-artifact@v4
        with:
          name: desktop-windows-amd64
          path: desktop-builds/

      - name: Create MSIX Package
        shell: pwsh
        run: |
          Write-Host "Creating MSIX package..."
          $msixDir = "msix-package"
          $templateDir = "msix-package-amd64"

          if (-not (Test-Path $templateDir)) {
            Write-Error "‚ùå Template directory '$templateDir' not found. Unable to build MSIX."
            exit 1
          }

          if (Test-Path $msixDir) {
            Remove-Item $msixDir -Recurse -Force
          }
          Copy-Item $templateDir $msixDir -Recurse

          $possiblePaths = @(
            "desktop-builds/windows/amd64/whodb.exe",
            "desktop-builds/build/windows/amd64/whodb.exe",
            "desktop-builds/whodb.exe",
            "desktop-builds/whodb-amd64.exe"
          )
          $exeFound = $false
          foreach ($path in $possiblePaths) {
            if (Test-Path $path) {
              Copy-Item $path "$msixDir/whodb.exe"
              Write-Host "‚úÖ Found and copied executable from: $path"
              $exeFound = $true
              break
            }
          }

          if (-not $exeFound) {
            Write-Error "‚ùå Executable not found in any expected location"
            exit 1
          }

          $manifestPath = Join-Path $msixDir "AppxManifest.xml"
          if (-not (Test-Path $manifestPath)) {
            Write-Error "‚ùå AppxManifest.xml not found in template directory"
            exit 1
          }

          [xml]$manifestXml = Get-Content $manifestPath
          $version = "${{ inputs.version }}"
          if ($version.Split('.').Count -lt 4) {
            $version = "$version.0"
          }
          $manifestXml.Package.Identity.Version = $version
          $manifestXml.Save($manifestPath)

          $makeAppx = (where.exe makeappx.exe 2>$null | Select-Object -First 1)
          if (-not $makeAppx) {
            Write-Error "MakeAppx.exe not found"
            exit 1
          }

          $outputPath = "WhoDB_${{ inputs.version }}.msixbundle"
          & $makeAppx pack /d $msixDir /p $outputPath /v
          if ($LASTEXITCODE -ne 0) { exit 1 }
          Write-Host "‚úÖ MSIX package created: $outputPath"

      - name: Upload Windows package
        uses: actions/upload-artifact@v4
        with:
          name: windows-msix
          path: "*.msixbundle"
          retention-days: 1

  deploy-microsoft-store:
    name: Submit to Microsoft Store
    runs-on: windows-latest
    needs: [ package-windows-msix ]
    continue-on-error: ${{ inputs.stage-only }}
    steps:
      - name: Checkout for scripts
        uses: actions/checkout@v4

      - name: Check Microsoft Store credentials
        id: check_creds
        shell: pwsh
        run: |
          $hasAllCreds = ("${{ secrets.MS_TENANT_ID }}" -ne "") -and
                        ("${{ secrets.MS_CLIENT_ID }}" -ne "") -and
                        ("${{ secrets.MS_CLIENT_SECRET }}" -ne "") -and
                        ("${{ secrets.MS_APP_ID }}" -ne "")

          if ($hasAllCreds) {
            Write-Host "‚úÖ All Microsoft Store credentials are configured"
            echo "has_creds=true" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "‚ö†Ô∏è Microsoft Store credentials missing"
            if ("${{ inputs.stage-only }}" -eq "true") {
              echo "has_creds=false" >> $env:GITHUB_OUTPUT
            } else {
              Write-Error "Production deployment requires all Microsoft Store credentials"
              exit 1
            }
          }

      - name: Download MSIX package
        if: steps.check_creds.outputs.has_creds == 'true'
        uses: actions/download-artifact@v4
        with:
          name: windows-msix
          path: .

      - name: Setup StoreBroker Module
        if: steps.check_creds.outputs.has_creds == 'true'
        shell: pwsh
        run: |
          if (!(Get-Module -ListAvailable -Name StoreBroker)) {
            Install-Module -Name StoreBroker -Force -Scope CurrentUser -AllowClobber
          }
          Write-Host "‚úÖ StoreBroker ready"

      - name: Replace MSIX bundle and submit
        if: steps.check_creds.outputs.has_creds == 'true'
        shell: pwsh
        env:
          MS_TENANT_ID: ${{ secrets.MS_TENANT_ID }}
          MS_CLIENT_ID: ${{ secrets.MS_CLIENT_ID }}
          MS_CLIENT_SECRET: ${{ secrets.MS_CLIENT_SECRET }}
          MS_APP_ID: ${{ secrets.MS_APP_ID }}
        run: |
          Import-Module StoreBroker -Force
          $global:SBDisableTelemetry = $true
          $securePassword = ConvertTo-SecureString $env:MS_CLIENT_SECRET -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential($env:MS_CLIENT_ID, $securePassword)
          Set-StoreBrokerAuthentication -TenantId $env:MS_TENANT_ID -Credential $credential

          $appId = $env:MS_APP_ID
          $msixPath = Get-ChildItem -Path "." -Filter "*.msixbundle" | Select-Object -First 1
          if (-not $msixPath) {
            Write-Error "‚ùå MSIX bundle artifact not found"
            exit 1
          }

          Write-Host "‚úÖ Using bundle: $($msixPath.FullName)"

          $submission = New-ApplicationSubmission -AppId $appId -NoStatus
          if (-not $submission) {
            Write-Error "‚ùå Failed to clone latest submission for application $appId"
            exit 1
          }

          if (-not $submission.applicationPackages -or $submission.applicationPackages.Count -eq 0) {
            Write-Error "‚ùå Submission clone does not contain any packages; cannot continue"
            exit 1
          }

          $originalPackages = $submission.applicationPackages | ForEach-Object { $_ }
          $submission.applicationPackages | ForEach-Object { $_.fileStatus = "PendingDelete" }

          $primaryPackage = $originalPackages | Select-Object -First 1
          $packageJson = $primaryPackage | ConvertTo-Json -Depth 32
          $newPackage = $packageJson | ConvertFrom-Json

          $bundleName = $msixPath.Name
          $bundleSize = (Get-Item $msixPath.FullName).Length

          $newPackage.fileName = $bundleName
          $newPackage.fileStatus = "PendingUpload"
          if ($newPackage.PSObject.Properties.Name -contains "fileSize") {
            $newPackage.fileSize = $bundleSize
          } else {
            $newPackage | Add-Member -NotePropertyName fileSize -NotePropertyValue $bundleSize
          }
          if ($newPackage.PSObject.Properties.Name -contains "version") {
            $normalizedVersion = "${{ inputs.version }}"
            if ($normalizedVersion -notmatch '^\d+\.\d+\.\d+\.\d+$') {
              $normalizedVersion = "$normalizedVersion.0"
            }
            $newPackage.version = $normalizedVersion
          }

          foreach ($prop in @("fileUploadUrl", "fileUploadStatus", "uploadUrl", "id")) {
            if ($newPackage.PSObject.Properties.Name -contains $prop) {
              $newPackage.PSObject.Properties.Remove($prop)
            }
          }

          $submission.applicationPackages += $newPackage

          foreach ($prop in @("appId", "iapId")) {
            if ($submission.PSObject.Properties.Name -contains $prop) {
              $submission.PSObject.Properties.Remove($prop)
            }
          }
          foreach ($pkg in $submission.applicationPackages) {
            foreach ($prop in @("version","architecture","targetPlatform","languages","capabilities","targetDeviceFamilies","targetDeviceFamiliesEx","minOSVersion","innerPackages")) {
              if ($pkg.PSObject.Properties.Name -contains $prop) {
                $pkg.PSObject.Properties.Remove($prop)
              }
            }
          }

          $updatedSubmission = Set-ApplicationSubmission -AppId $appId -UpdatedSubmission $submission -NoStatus
          if (-not $updatedSubmission) {
            Write-Error "‚ùå Failed to update submission with new package metadata"
            exit 1
          }

          $uploadUrl = $updatedSubmission.fileUploadUrl
          if ([string]::IsNullOrWhiteSpace($uploadUrl)) {
            Write-Error "‚ùå Store API did not return an upload URL for the submission"
            exit 1
          }

          $stagingDir = Join-Path $PWD "ms-store-upload"
          if (Test-Path $stagingDir) {
            Remove-Item $stagingDir -Recurse -Force
          }
          New-Item -ItemType Directory -Path $stagingDir | Out-Null
          Copy-Item $msixPath.FullName (Join-Path $stagingDir $bundleName)

          $submissionZip = Join-Path $PWD "submission-package.zip"
          if (Test-Path $submissionZip) {
            Remove-Item $submissionZip -Force
          }
          Compress-Archive -Path (Join-Path $stagingDir $bundleName) -DestinationPath $submissionZip -CompressionLevel Optimal

          Set-SubmissionPackage -PackagePath $submissionZip -UploadUrl $uploadUrl -NoStatus

          if (Test-Path $submissionZip) {
            Remove-Item $submissionZip -Force
          }
          if (Test-Path $stagingDir) {
            Remove-Item $stagingDir -Recurse -Force
          }

          if ("${{ inputs.stage-only }}" -eq "true") {
            Write-Host "‚úÖ Submission updated and left as draft (stage-only mode)"
          } else {
            Complete-ApplicationSubmission -AppId $appId -SubmissionId $updatedSubmission.id -NoStatus
            $statusCheck = 0
            $finalStatus = $null
            do {
              Start-Sleep -Seconds 10
              $finalSubmission = Get-ApplicationSubmission -AppId $appId -SubmissionId $updatedSubmission.id -NoStatus
              $finalStatus = $finalSubmission.status
              $statusCheck++
            } while ($statusCheck -lt 6 -and $finalStatus -eq "PendingCommit")

            Write-Host "üöÄ Submission committed for certification"
            Write-Host "‚ÑπÔ∏è Store submission status: $finalStatus"
            if ($finalStatus -eq "PendingCommit") {
              Write-Warning "Submission still shows PendingCommit after commit. Certification state may take longer to appear."
            }
          }
