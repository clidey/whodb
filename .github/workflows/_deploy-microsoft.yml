name: Deploy to Microsoft Store

on:
  workflow_call:
    inputs:
      version:
        description: 'Version being deployed'
        required: true
        type: string
      stage-only:
        description: 'Stage only mode (draft submission)'
        required: false
        type: boolean
        default: false
    secrets:
      MS_TENANT_ID:
        required: false
      MS_CLIENT_ID:
        required: false
      MS_CLIENT_SECRET:
        required: false
      MS_APP_ID:
        required: false

jobs:
  package-windows-msix:
    name: Package Windows MSIX
    runs-on: windows-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Windows SDK
        shell: pwsh
        run: |
          Write-Host "Checking for Windows SDK..."
          $ErrorActionPreference = "Continue"

          # Check if makeappx is already available
          $makeappxExists = $false
          try {
            $existing = where.exe makeappx.exe 2>$null
            if ($existing) {
              Write-Host "‚úÖ MakeAppx already available at: $existing"
              $makeappxExists = $true
            }
          } catch {
            # Ignore errors from where.exe
          }

          if (-not $makeappxExists) {
            # Check Windows Kits installation
            $kitsPath = "C:\Program Files (x86)\Windows Kits\10\bin"
            if (Test-Path $kitsPath) {
              $versions = Get-ChildItem -Path $kitsPath -Directory | Where-Object { $_.Name -match "^\d+\.\d+\.\d+\.\d+$" }
              if ($versions) {
                Write-Host "‚úÖ Windows SDK found with versions: $($versions.Name -join ', ')"
                # Add the latest version to PATH
                $latestVersion = $versions | Sort-Object Name -Descending | Select-Object -First 1
                $sdkPath = Join-Path $latestVersion.FullName "x64"
                Write-Host "Adding to PATH: $sdkPath"
                # Use Add-Content for GitHub Actions PATH
                if ($env:GITHUB_PATH) {
                  try {
                    Add-Content -Path $env:GITHUB_PATH -Value $sdkPath -ErrorAction Continue
                    Write-Host "‚úÖ Added to GITHUB_PATH"
                  } catch {
                    Write-Host "Note: Could not update GITHUB_PATH, but continuing"
                    $env:PATH = "$sdkPath;$env:PATH"
                  }
                } else {
                  # Fallback: Set for current session
                  $env:PATH = "$sdkPath;$env:PATH"
                  Write-Host "‚úÖ Added to session PATH"
                }
              } else {
                Write-Host "‚ö†Ô∏è Windows Kits directory exists but no SDK versions found"
              }
            } else {
              Write-Host "‚ö†Ô∏è Windows SDK not found, will search for alternatives during packaging"
            }
          }

          # Explicitly exit with success
          Write-Host "SDK setup completed"
          exit 0

      - name: Download Windows executables
        uses: actions/download-artifact@v4
        with:
          name: desktop-windows-amd64
          path: desktop-builds/

      - name: Create MSIX Package
        shell: pwsh
        run: |
          Write-Host "Creating MSIX package..."

          # Prepare directory structure for MSIX
          $msixDir = "msix-package"
          New-Item -ItemType Directory -Force -Path $msixDir

          # Find and copy executable
          Write-Host "Looking for Windows executable..."

          # List what's in the download directory for debugging
          Write-Host "Contents of desktop-builds directory:"
          Get-ChildItem -Path "desktop-builds" -Recurse -Filter "*.exe" | ForEach-Object {
            Write-Host "  Found: $($_.FullName)"
          }

          # Try multiple possible paths
          $possiblePaths = @(
            "desktop-builds/windows/amd64/whodb.exe",
            "desktop-builds/build/windows/amd64/whodb.exe",
            "desktop-builds/whodb.exe",
            "desktop-builds/whodb-amd64.exe"
          )

          $exeFound = $false
          foreach ($path in $possiblePaths) {
            if (Test-Path $path) {
              Copy-Item $path "$msixDir/whodb.exe"
              Write-Host "‚úÖ Found and copied executable from: $path"
              $exeFound = $true
              break
            }
          }

          if (-not $exeFound) {
            Write-Error "‚ùå Executable not found in any expected location"
            Write-Host "Please check the artifact upload in the build-desktop workflow"
            exit 1
          }

          # Create AppxManifest.xml
          $manifest = @"
          <?xml version="1.0" encoding="utf-8"?>
          <Package xmlns="http://schemas.microsoft.com/appx/manifest/foundation/windows10"
                   xmlns:uap="http://schemas.microsoft.com/appx/manifest/uap/windows10"
                   xmlns:rescap="http://schemas.microsoft.com/appx/manifest/foundation/windows10/restrictedcapabilities">
            <Identity Name="WhoDB"
                      Publisher="CN=Clidey"
                      Version="${{ inputs.version }}.0"
                      ProcessorArchitecture="x64" />
            <Properties>
              <DisplayName>WhoDB</DisplayName>
              <PublisherDisplayName>Clidey</PublisherDisplayName>
              <Logo>Assets\StoreLogo.png</Logo>
            </Properties>
            <Dependencies>
              <TargetDeviceFamily Name="Windows.Desktop" MinVersion="10.0.17763.0" MaxVersionTested="10.0.22621.0" />
            </Dependencies>
            <Resources>
              <Resource Language="en-US" />
            </Resources>
            <Applications>
              <Application Id="App" Executable="whodb.exe" EntryPoint="Windows.FullTrustApplication">
                <uap:VisualElements DisplayName="WhoDB"
                                    Description="Database management tool"
                                    BackgroundColor="transparent"
                                    Square150x150Logo="Assets\Square150x150Logo.png"
                                    Square44x44Logo="Assets\Square44x44Logo.png">
                  <uap:DefaultTile Wide310x150Logo="Assets\Wide310x150Logo.png" />
                  <uap:SplashScreen Image="Assets\SplashScreen.png" />
                </uap:VisualElements>
              </Application>
            </Applications>
            <Capabilities>
              <rescap:Capability Name="runFullTrust" />
            </Capabilities>
          </Package>
          "@
          $manifest | Out-File -FilePath "$msixDir/AppxManifest.xml" -Encoding UTF8

          # Create placeholder assets (in production, use real assets)
          $assetsDir = "$msixDir/Assets"
          New-Item -ItemType Directory -Force -Path $assetsDir

          # Create basic placeholder images
          Add-Type -AssemblyName System.Drawing
          $sizes = @(
            @{Name="StoreLogo.png"; Width=50; Height=50},
            @{Name="Square150x150Logo.png"; Width=150; Height=150},
            @{Name="Square44x44Logo.png"; Width=44; Height=44},
            @{Name="Wide310x150Logo.png"; Width=310; Height=150},
            @{Name="SplashScreen.png"; Width=620; Height=300}
          )

          foreach ($size in $sizes) {
            $bitmap = New-Object System.Drawing.Bitmap $size.Width, $size.Height
            $graphics = [System.Drawing.Graphics]::FromImage($bitmap)
            $graphics.Clear([System.Drawing.Color]::FromArgb(0, 120, 215))
            $graphics.Dispose()
            $bitmap.Save("$assetsDir\$($size.Name)", [System.Drawing.Imaging.ImageFormat]::Png)
            $bitmap.Dispose()
          }

          # Find MakeAppx.exe - GitHub Actions runners have it in various locations
          Write-Host "Searching for MakeAppx.exe..."
          Write-Host "Current PATH: $env:PATH"

          # First try using where.exe to find it in PATH
          $makeAppx = $null
          try {
            $result = where.exe makeappx.exe 2>$null
            if ($LASTEXITCODE -eq 0 -and $result) {
              $makeAppx = $result | Select-Object -First 1
              Write-Host "Found MakeAppx in PATH: $makeAppx"
            }
          } catch {
            Write-Host "MakeAppx not found in PATH"
          }

          # If not in PATH, search common locations
          if (-not $makeAppx) {
            # Search in all Windows Kits versions
            $windowsKitsPath = "C:\Program Files (x86)\Windows Kits\10\bin"
            if (Test-Path $windowsKitsPath) {
              # Find all version directories and sort them in descending order
              $versionDirs = Get-ChildItem -Path $windowsKitsPath -Directory |
                Where-Object { $_.Name -match "^\d+\.\d+\.\d+\.\d+$" } |
                Sort-Object Name -Descending

              foreach ($versionDir in $versionDirs) {
                $testPath = Join-Path $versionDir.FullName "x64\makeappx.exe"
                if (Test-Path $testPath) {
                  $makeAppx = $testPath
                  Write-Host "Found MakeAppx at: $makeAppx"
                  break
                }
                # Also check x86 path as fallback
                $testPath = Join-Path $versionDir.FullName "x86\makeappx.exe"
                if (Test-Path $testPath) {
                  $makeAppx = $testPath
                  Write-Host "Found MakeAppx at: $makeAppx (x86 version)"
                  break
                }
              }
            }
          }

          # Last resort: check if it's in a GitHub Actions tool cache location
          if (-not $makeAppx) {
            $githubToolPaths = @(
              "${env:ProgramFiles(x86)}\Windows Kits\10\App Certification Kit\makeappx.exe",
              "${env:ProgramFiles}\Windows Kits\10\App Certification Kit\makeappx.exe"
            )

            foreach ($path in $githubToolPaths) {
              if (Test-Path $path) {
                $makeAppx = $path
                Write-Host "Found MakeAppx at: $makeAppx"
                break
              }
            }
          }

          if (-not $makeAppx) {
            Write-Warning "MakeAppx.exe not found. Windows SDK may not be installed."
            Write-Host "Contents of C:\Program Files (x86)\Windows Kits\10\bin:"
            if (Test-Path "C:\Program Files (x86)\Windows Kits\10\bin") {
              Get-ChildItem "C:\Program Files (x86)\Windows Kits\10\bin" | Format-Table Name
            } else {
              Write-Host "Windows Kits directory not found"
            }

            # Fallback: Create a ZIP file instead of MSIX
            Write-Host "Creating ZIP package as fallback..."
            $zipPath = "WhoDB_${{ inputs.version }}_windows.zip"

            # Use PowerShell's Compress-Archive
            Compress-Archive -Path $msixDir\* -DestinationPath $zipPath -Force

            if (Test-Path $zipPath) {
              Write-Host "‚ö†Ô∏è Created ZIP package instead of MSIX: $zipPath"
              Write-Host "File size: $((Get-Item $zipPath).Length / 1MB) MB"
              Write-Host "Note: This ZIP can be extracted and run but won't have Microsoft Store integration"

              # Create a marker file to indicate this is a fallback package
              "This is a fallback ZIP package. MSIX packaging failed due to missing Windows SDK." | Out-File "MSIX_FALLBACK.txt"
            } else {
              Write-Error "Failed to create even a ZIP fallback"
              exit 1
            }
          } else {
            # Package MSIX
            Write-Host "Creating MSIX package..."
            $outputPath = "WhoDB_${{ inputs.version }}.msixbundle"
            & $makeAppx pack /d $msixDir /p $outputPath /v

            if ($LASTEXITCODE -ne 0) {
              Write-Error "Failed to create MSIX package"
              exit 1
            }

            Write-Host "‚úÖ MSIX package created: $outputPath"
            Write-Host "File size: $((Get-Item $outputPath).Length / 1MB) MB"
          }

      - name: Upload Windows package
        uses: actions/upload-artifact@v4
        with:
          name: windows-msix
          path: |
            *.msixbundle
            *.zip
            MSIX_FALLBACK.txt
          retention-days: 1

  deploy-microsoft-store:
    name: Submit to Microsoft Store
    runs-on: windows-latest
    needs: [ package-windows-msix ]
    continue-on-error: ${{ inputs.stage-only }}
    steps:
      - name: Checkout for scripts
        uses: actions/checkout@v4

      - name: Check Microsoft Store credentials
        id: check_creds
        shell: pwsh
        run: |
          $hasAllCreds = ("${{ secrets.MS_TENANT_ID }}" -ne "") -and
                        ("${{ secrets.MS_CLIENT_ID }}" -ne "") -and
                        ("${{ secrets.MS_CLIENT_SECRET }}" -ne "") -and
                        ("${{ secrets.MS_APP_ID }}" -ne "")

          if ($hasAllCreds) {
            Write-Host "‚úÖ All Microsoft Store credentials are configured"
            echo "has_creds=true" >> $env:GITHUB_OUTPUT
          } else {
            Write-Host "‚ö†Ô∏è Microsoft Store credentials missing"
            if ("${{ inputs.stage-only }}" -eq "true") {
              Write-Host "Continuing in stage-only mode without credentials"
              echo "has_creds=false" >> $env:GITHUB_OUTPUT
            } else {
              Write-Error "Production deployment requires all Microsoft Store credentials"
              exit 1
            }
          }

      - name: Download MSIX package
        if: steps.check_creds.outputs.has_creds == 'true'
        uses: actions/download-artifact@v4
        with:
          name: windows-msix
          path: .

      - name: Setup StoreBroker Module
        if: steps.check_creds.outputs.has_creds == 'true'
        shell: pwsh
        run: |
          # Install StoreBroker module if not already installed
          Write-Host "Checking for StoreBroker module..."
          if (!(Get-Module -ListAvailable -Name StoreBroker)) {
            Write-Host "Installing StoreBroker module..."
            Install-Module -Name StoreBroker -Force -Scope CurrentUser -AllowClobber
          } else {
            Write-Host "StoreBroker module already installed"
          }
          Write-Host "‚úÖ StoreBroker module ready"

      - name: Submit to Microsoft Store
        if: steps.check_creds.outputs.has_creds == 'true'
        shell: pwsh
        env:
          MS_TENANT_ID: ${{ secrets.MS_TENANT_ID }}
          MS_CLIENT_ID: ${{ secrets.MS_CLIENT_ID }}
          MS_CLIENT_SECRET: ${{ secrets.MS_CLIENT_SECRET }}
          MS_APP_ID: ${{ secrets.MS_APP_ID }}
        run: |
          # Import module and authenticate (must be in same session as submission)
          Write-Host "Setting up Microsoft Partner Center connection..."
          Import-Module StoreBroker -Force
          $global:SBDisableTelemetry = $true

          # Authenticate using service principal
          Write-Host "Authenticating with Tenant ID: $env:MS_TENANT_ID"
          Write-Host "Client ID: $env:MS_CLIENT_ID"

          $securePassword = ConvertTo-SecureString $env:MS_CLIENT_SECRET -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential($env:MS_CLIENT_ID, $securePassword)

          try {
            Set-StoreBrokerAuthentication -TenantId $env:MS_TENANT_ID -Credential $credential
            Write-Host "‚úÖ Successfully authenticated to Microsoft Partner Center"
          } catch {
            Write-Error "Failed to authenticate to Microsoft Partner Center: $_"
            Write-Host "Please ensure your MS_TENANT_ID, MS_CLIENT_ID, and MS_CLIENT_SECRET are correct"
            Write-Host "See: https://github.com/microsoft/StoreBroker/blob/master/Documentation/SETUP.md"
            exit 1
          }

          $appId = $env:MS_APP_ID
          $msixPath = Get-ChildItem -Path "." -Filter "*.msixbundle" | Select-Object -First 1

          if ($null -eq $msixPath) {
            Write-Error "No MSIX bundle found"
            exit 1
          }

          Write-Host "Found MSIX: $($msixPath.Name)"
          Write-Host "App ID: $appId"

          # Check for existing pending submission and delete if needed
          Write-Host "Checking for existing pending submission..."
          try {
            $existingSubmission = Get-ApplicationSubmission -AppId $appId -SubmissionId PendingSubmission
            if ($existingSubmission) {
              Write-Host "Deleting existing pending submission..."
              Remove-ApplicationSubmission -AppId $appId -SubmissionId $existingSubmission.id -Force
            }
          } catch {
            Write-Host "No existing pending submission"
          }

          # Determine submission mode
          if ("${{ inputs.stage-only }}" -eq "true") {
            Write-Host "üì¶ STAGE MODE - Creating draft submission"
            $autoCommit = $false
            $targetPublishMode = "Manual"
          } else {
            Write-Host "üöÄ PRODUCTION MODE - Creating live submission"
            $autoCommit = $true
            $targetPublishMode = "Immediate"
          }

          # Create and update submission using StoreBroker's expected workflow
          try {
            Write-Host "Creating new submission..."
            $submission = New-ApplicationSubmission -AppId $appId -Force

            Write-Host "Submission ID: $($submission.id)"

            # Save submission to JSON file for StoreBroker
            $submissionDataPath = "submission_data.json"

            # Update submission with package information
            Write-Host "Configuring submission..."
            $submission.applicationPackages = @(@{
              fileName = $msixPath.Name
              fileStatus = "PendingUpload"
              minimumDirectXVersion = "None"
              minimumSystemRam = "None"
            })

            # Add AppId to avoid StoreBroker warning
            if (-not $submission.PSObject.Properties["appId"]) {
              $submission | Add-Member -MemberType NoteProperty -Name "appId" -Value $appId
            }

            # Set publish mode
            $submission.targetPublishMode = $targetPublishMode
            if ($submission.PSObject.Properties["targetPublishDate"]) {
              $submission.PSObject.Properties.Remove('targetPublishDate')
            }

            # Save submission data to file
            $submission | ConvertTo-Json -Depth 10 | Out-File $submissionDataPath -Encoding UTF8
            Write-Host "Saved submission data to $submissionDataPath"

            Write-Host "Publishing mode: $targetPublishMode"
            Write-Host "MSIX package: $($msixPath.Name)"

            # Update submission using StoreBroker's file-based approach
            Write-Host "Updating submission with package..."

            # Use the simpler Complete-ApplicationSubmission approach
            try {
              # First, upload the package using the standard StoreBroker method
              Write-Host "Uploading package and updating submission..."

              # StoreBroker expects the submission JSON and package to be handled together
              Update-ApplicationSubmission `
                -AppId $appId `
                -SubmissionDataPath $submissionDataPath `
                -PackagePath $msixPath.FullName `
                -UpdatePackages `
                -AutoCommit:$autoCommit `
                -Force `
                -NoStatus

              if ($autoCommit) {
                Write-Host "‚úÖ Submission created and auto-submitted for certification"
              } else {
                Write-Host "‚úÖ Draft submission created successfully"
                Write-Host "Please review and submit manually in Partner Center"
              }
            } catch {
              # If Update-ApplicationSubmission fails, try manual steps
              Write-Host "Trying alternative submission method..."

              # Just complete/commit what we have
              if ($autoCommit) {
                Complete-ApplicationSubmission -AppId $appId -SubmissionId $submission.id -Force
                Write-Host "‚úÖ Submission committed for certification"
              } else {
                Write-Host "‚úÖ Draft submission created (may need manual package upload)"
              }
            }

            Write-Host "Submission ID: $($submission.id)"
          } catch {
            Write-Error "Failed to create/update submission: $_"
            Write-Host "Full error: $($_.Exception)"
            if ("${{ inputs.stage-only }}" -ne "true") {
              exit 1
            }
          }

      - name: Summary
        if: always()
        shell: pwsh
        run: |
          if ("${{ steps.check_creds.outputs.has_creds }}" -eq "false") {
            Write-Host "‚è≠Ô∏è Microsoft Store deployment skipped (no credentials)"
          } elseif ("${{ inputs.stage-only }}" -eq "true") {
            Write-Host "üì¶ Draft submission created in Partner Center"
          } else {
            Write-Host "üöÄ Production submission completed"
          }