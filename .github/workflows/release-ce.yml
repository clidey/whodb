name: Build, Stage, and Deploy Release

on:
  pull_request:
    types: [ closed ]
    branches: [ release ]
  workflow_dispatch:
    inputs:
      dry_run:
        description: 'Dry run mode (no actual deployments)'
        required: false
        type: boolean
        default: true

jobs:
  calculate-version:
    name: Calculate Next Version
    runs-on: ubuntu-latest
    if: github.event_name == 'workflow_dispatch' || (github.event.pull_request.merged == true && github.event.pull_request.base.ref == 'release')
    outputs:
      version: ${{ steps.version.outputs.version }}
      previous_version: ${{ steps.version.outputs.previous_version }}
      dry_run: ${{ steps.dry_run.outputs.enabled }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set dry run mode
        id: dry_run
        run: |
          if [ "${{ github.event_name }}" = "workflow_dispatch" ]; then
            DRY_RUN="${{ inputs.dry_run }}"
          else
            # PR merges to release branch are always production
            DRY_RUN="false"
          fi
          echo "enabled=$DRY_RUN" >> $GITHUB_OUTPUT
          echo "Dry run mode: $DRY_RUN"

      - name: Check all secrets availability
        run: |
          echo "üîê SECRET AVAILABILITY CHECK"
          echo "============================"
          echo ""
          echo "üì¶ Docker Hub:"
          [ -n "${{ secrets.DOCKERHUB_USERNAME }}" ] && echo "  ‚úÖ DOCKERHUB_USERNAME" || echo "  ‚ùå DOCKERHUB_USERNAME"
          [ -n "${{ secrets.DOCKERHUB_TOKEN }}" ] && echo "  ‚úÖ DOCKERHUB_TOKEN" || echo "  ‚ùå DOCKERHUB_TOKEN"
          echo ""
          echo "üì¶ Snap Store:"
          [ -n "${{ secrets.SNAPCRAFT_STORE_CREDENTIALS }}" ] && echo "  ‚úÖ SNAPCRAFT_STORE_CREDENTIALS" || echo "  ‚ùå SNAPCRAFT_STORE_CREDENTIALS"
          echo ""
          echo "ü™ü Microsoft Store:"
          [ -n "${{ secrets.MS_TENANT_ID }}" ] && echo "  ‚úÖ MS_TENANT_ID" || echo "  ‚ùå MS_TENANT_ID"
          [ -n "${{ secrets.MS_CLIENT_ID }}" ] && echo "  ‚úÖ MS_CLIENT_ID" || echo "  ‚ùå MS_CLIENT_ID"
          [ -n "${{ secrets.MS_CLIENT_SECRET }}" ] && echo "  ‚úÖ MS_CLIENT_SECRET" || echo "  ‚ùå MS_CLIENT_SECRET"
          [ -n "${{ secrets.MS_APP_ID }}" ] && echo "  ‚úÖ MS_APP_ID" || echo "  ‚ùå MS_APP_ID"
          echo ""
          echo "üçé Mac App Store:"
          [ -n "${{ secrets.MAS_CODESIGN_ID }}" ] && echo "  ‚úÖ MAS_CODESIGN_ID" || echo "  ‚ùå MAS_CODESIGN_ID"
          [ -n "${{ secrets.MAS_INSTALLER_ID }}" ] && echo "  ‚úÖ MAS_INSTALLER_ID" || echo "  ‚ùå MAS_INSTALLER_ID"
          echo ""
          echo "üçé Apple Store Connect API:"
          [ -n "${{ secrets.APP_STORE_CONNECT_API_KEY }}" ] && echo "  ‚úÖ APP_STORE_CONNECT_API_KEY" || echo "  ‚ùå APP_STORE_CONNECT_API_KEY"
          [ -n "${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}" ] && echo "  ‚úÖ APP_STORE_CONNECT_API_KEY_ID" || echo "  ‚ùå APP_STORE_CONNECT_API_KEY_ID"
          [ -n "${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}" ] && echo "  ‚úÖ APP_STORE_CONNECT_ISSUER_ID" || echo "  ‚ùå APP_STORE_CONNECT_ISSUER_ID"
          [ -n "${{ secrets.APPLE_ID }}" ] && echo "  ‚úÖ APPLE_ID" || echo "  ‚ùå APPLE_ID"
          echo ""
          echo "============================"
          echo ""

      - name: Calculate version
        id: version
        run: |
          NEXT_VERSION=$(bash scripts/version-bump.sh)
          LATEST_TAG=$(git describe --tags --abbrev=0 2>/dev/null || echo "v0.0.0")
          PREVIOUS_VERSION="${LATEST_TAG#v}"
          echo "version=$NEXT_VERSION" >> $GITHUB_OUTPUT
          echo "previous_version=$PREVIOUS_VERSION" >> $GITHUB_OUTPUT
          echo "Next version: $NEXT_VERSION"
          echo "Previous version: $PREVIOUS_VERSION"

  build-docker-ce:
    name: Build Docker Images (CE)
    strategy:
      matrix:
        include:
          - runner: ubuntu-latest
            platform: linux/amd64
            arch: amd64
          - runner: ubuntu-24.04-arm  # Native ARM64 build
            platform: linux/arm64
            arch: arm64
    runs-on: ${{ matrix.runner }}
    needs: calculate-version
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Build Docker image for ${{ matrix.platform }}
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./core/Dockerfile
          platforms: ${{ matrix.platform }}
          push: false
          tags: clidey/whodb:${{ needs.calculate-version.outputs.version }}-${{ matrix.arch }}
          outputs: type=oci,dest=/tmp/whodb-docker-${{ matrix.arch }}.tar

      - name: Upload Docker artifact
        uses: actions/upload-artifact@v4
        with:
          name: docker-image-${{ matrix.arch }}
          path: /tmp/whodb-docker-${{ matrix.arch }}.tar
          retention-days: 1

  # Build desktop executables for store packaging
  build-desktop-ce:
    name: Build Desktop Executables (CE)
    strategy:
      matrix:
        include:
          # Windows builds for Microsoft Store
          - os: windows-latest
            platform: windows
            arch: amd64
            make-target: build-prod-windows-amd64
          - os: windows-11-arm  # Use native ARM64 runner for Windows ARM64
            platform: windows
            arch: arm64
            make-target: build-prod-windows-arm64
          # macOS build for Mac App Store
          - os: macos-latest
            platform: darwin
            arch: universal
            make-target: build-prod-mac
    runs-on: ${{ matrix.os }}
    needs: calculate-version
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Go
        uses: actions/setup-go@v5
        with:
          go-version-file: 'desktop-ce/go.mod'

      - name: Setup Node.js and pnpm
        uses: actions/setup-node@v4
        with:
          node-version: 'lts/*'

      - uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Install frontend dependencies
        working-directory: ./frontend
        run: pnpm i

      - name: Install Wails CLI
        run: go install github.com/wailsapp/wails/v2/cmd/wails@latest

      - name: Setup ARM64 compiler on Windows ARM
        if: matrix.platform == 'windows' && matrix.arch == 'arm64'
        shell: pwsh
        run: |
          Write-Host "Checking available GCC compilers..."
          Get-Command gcc -ErrorAction SilentlyContinue | Format-List
          Write-Host "Go environment:"
          go env GOARCH
          go env CC
          Write-Host "Setting GOARCH=arm64 explicitly..."
          $env:GOARCH = "arm64"
          Write-Host "Updated GOARCH:"
          go env GOARCH

      - name: Build Windows
        if: matrix.platform == 'windows' && matrix.arch == 'amd64'
        working-directory: ./desktop-ce
        shell: pwsh
        env:
          GOARCH: ${{ matrix.arch }}
        run: |
          # Build raw exe for MSIX packaging (not NSIS installer)
          Write-Host "Building raw Windows executable for MSIX packaging..."
          $env:GOWORK = "$PWD/../go.work.desktop-ce"

          # Clean previous build
          Remove-Item -Path build -Recurse -Force -ErrorAction SilentlyContinue

          # Prepare frontend
          Write-Host "Preparing frontend..."
          New-Item -ItemType Directory -Path frontend/dist -Force | Out-Null
          Set-Location ../frontend
          pnpm run build:ce
          Copy-Item -Path build/* -Destination ../desktop-ce/frontend/dist/ -Recurse
          Set-Location ../desktop-ce

          # Build without NSIS flag to get raw exe
          Write-Host "Building with wails..."
          $wailsPath = Join-Path $env:USERPROFILE "go\bin\wails.exe"
          if (-not (Test-Path $wailsPath)) {
              Write-Host "Wails not found at $wailsPath, trying PATH..."
              $wailsPath = "wails"
          }

          & $wailsPath build -clean -platform windows/amd64 `
            -windowsconsole=false -ldflags="-s -w -H windowsgui" `
            -o whodb.exe

          if ($LASTEXITCODE -ne 0) {
              Write-Error "Wails build failed with exit code: $LASTEXITCODE"
              exit 1
          }

          # Find where wails actually put the exe
          Write-Host "Looking for built executable..."
          Write-Host "Contents of build directory:"
          Get-ChildItem -Path build -Recurse -ErrorAction SilentlyContinue | Format-Table Name, FullName

          # Check common locations
          $possibleLocations = @(
              "build\bin\whodb.exe",
              "build\bin\whodb-amd64.exe",
              "build\whodb.exe"
          )

          $foundExe = $null
          foreach ($location in $possibleLocations) {
              if (Test-Path $location) {
                  $foundExe = $location
                  Write-Host "Found exe at: $foundExe"
                  break
              }
          }

          if (-not $foundExe) {
              Write-Error "Could not find whodb.exe after build"
              exit 1
          }

          # Move to expected location
          New-Item -ItemType Directory -Path build/windows/amd64 -Force | Out-Null
          Move-Item $foundExe build/windows/amd64/whodb.exe -Force

          Write-Host "Raw executable moved to: build/windows/amd64/whodb.exe"
          Write-Host "Verifying final location..."
          if (Test-Path "build/windows/amd64/whodb.exe") {
              $fileInfo = Get-Item "build/windows/amd64/whodb.exe"
              Write-Host "‚úÖ Executable ready: $($fileInfo.FullName) (Size: $($fileInfo.Length) bytes)"
          } else {
              Write-Error "Failed to move executable to expected location"
              exit 1
          }

      - name: Skip Windows ARM64 Build (Temporarily Disabled)
        if: matrix.platform == 'windows' && matrix.arch == 'arm64'
        shell: pwsh
        run: |
          Write-Host "‚ö†Ô∏è Windows ARM64 build is temporarily disabled due to toolchain issues"
          Write-Host "Creating placeholder for build artifacts..."
          New-Item -ItemType Directory -Force -Path "./desktop-ce/build/windows/arm64"
          Write-Host "Skipping actual build..."

      - name: Build macOS
        if: matrix.platform == 'darwin'
        working-directory: ./desktop-ce
        run: make ${{ matrix.make-target }} VERSION=${{ needs.calculate-version.outputs.version }}

      - name: List build outputs before upload
        if: matrix.platform == 'windows' && matrix.arch == 'amd64'
        shell: pwsh
        working-directory: ./desktop-ce
        run: |
          Write-Host "üì¶ Listing build outputs before upload:"
          if (Test-Path "build") {
              Get-ChildItem -Path build -Recurse | Format-Table Name, FullName, Length
          } else {
              Write-Host "‚ùå Build directory does not exist!"
          }

      - name: Upload artifacts (AMD64 and macOS)
        if: matrix.arch != 'arm64' || matrix.platform != 'windows'
        uses: actions/upload-artifact@v4
        with:
          name: desktop-${{ matrix.platform }}-${{ matrix.arch || 'all' }}
          path: |
            desktop-ce/build/
          retention-days: 1

      - name: Skip ARM64 Artifacts Upload
        if: matrix.platform == 'windows' && matrix.arch == 'arm64'
        shell: pwsh
        run: |
          Write-Host "‚ö†Ô∏è Skipping ARM64 artifact upload (build was disabled)"

  # Package for Mac App Store
  package-mac-app-store:
    name: Package for Mac App Store
    runs-on: macos-latest
    needs: [ calculate-version, build-desktop-ce ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download macOS build
        uses: actions/download-artifact@v4
        with:
          name: desktop-darwin-universal
          path: desktop-ce/

      - name: Check certificate availability
        id: check_mac_cert
        run: |
          echo "üîç Checking Mac App Store certificates..."
          if [ -n "${{ secrets.MAS_CODESIGN_ID }}" ]; then
            echo "  ‚úÖ MAS_CODESIGN_ID is configured"
          else
            echo "  ‚ùå MAS_CODESIGN_ID is NOT configured"
          fi

          if [ -n "${{ secrets.MAS_INSTALLER_ID }}" ]; then
            echo "  ‚úÖ MAS_INSTALLER_ID is configured"
          else
            echo "  ‚ùå MAS_INSTALLER_ID is NOT configured"
          fi

          if [ -n "${{ secrets.MAS_CODESIGN_ID }}" ] && [ -n "${{ secrets.MAS_INSTALLER_ID }}" ]; then
            echo "has_cert=true" >> $GITHUB_OUTPUT
            echo "‚úÖ Mac certificates available - will build pkg package"
          else
            echo "has_cert=false" >> $GITHUB_OUTPUT
            echo "‚ö†Ô∏è Mac certificates not configured - will create dummy package"
          fi

      - name: Create dummy pkg for validation (no certs)
        if: steps.check_mac_cert.outputs.has_cert != 'true'
        run: |
          if [ "${{ needs.calculate-version.outputs.dry_run }}" = "true" ]; then
            echo "üèÉ DRY RUN MODE - No certificates available"
          else
            echo "‚ö†Ô∏è PRODUCTION MODE - No certificates available"
          fi
          echo "Creating dummy pkg for validation..."
          mkdir -p desktop-ce
          touch "desktop-ce/WhoDB-${{ needs.calculate-version.outputs.version }}.pkg"

      - name: Package for Mac App Store
        if: steps.check_mac_cert.outputs.has_cert == 'true'
        working-directory: ./desktop-ce
        env:
          MAS_CODESIGN_ID: ${{ secrets.MAS_CODESIGN_ID }}
          MAS_INSTALLER_ID: ${{ secrets.MAS_INSTALLER_ID }}
        run: |
          if [ "${{ needs.calculate-version.outputs.dry_run }}" = "true" ]; then
            echo "üèÉ DRY RUN MODE - Building Mac App Store package (will not publish)"
          fi

          # Sign the app for Mac App Store
          codesign --deep --force --options runtime --sign "$MAS_CODESIGN_ID" \
            "build/darwin/universal/WhoDB.app"

          # Create Mac App Store package
          productbuild --component "build/darwin/universal/WhoDB.app" /Applications \
            --sign "$MAS_INSTALLER_ID" \
            "WhoDB-${{ needs.calculate-version.outputs.version }}.pkg"

      - name: Upload Mac App Store package
        uses: actions/upload-artifact@v4
        with:
          name: mac-app-store
          path: desktop-ce/WhoDB-*.pkg
          retention-days: 1

  package-windows-msix:
    name: Package Windows MSIX
    runs-on: windows-latest
    needs: [ calculate-version, build-desktop-ce ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Windows SDK
        shell: pwsh
        run: |
          Write-Host "Checking for Windows SDK..."
          $sdkInstalled = Get-ItemProperty "HKLM:\SOFTWARE\WOW6432Node\Microsoft\Windows Kits\Installed Roots" -ErrorAction SilentlyContinue
          if ($sdkInstalled) {
              Write-Host "Windows SDK is already installed"
          } else {
              Write-Host "Installing Windows SDK components..."
              # The GitHub Windows runners should have SDK pre-installed
              Write-Host "Note: GitHub Actions Windows runners come with Windows SDK pre-installed"
          }

      - name: Download Windows amd64 builds
        uses: actions/download-artifact@v4
        with:
          name: desktop-windows-amd64
          path: desktop-ce/

      # ARM64 builds temporarily disabled
      # - name: Download Windows arm64 builds
      #   uses: actions/download-artifact@v4
      #   with:
      #     name: desktop-windows-arm64
      #     path: desktop-ce/

      - name: List downloaded Windows build artifacts
        shell: pwsh
        run: |
          Write-Host "üìÅ Current directory: $PWD"
          Write-Host ""
          Write-Host "üìÅ Contents of desktop-ce directory:"
          if (Test-Path "desktop-ce") {
              Get-ChildItem -Path "desktop-ce" -Recurse | Format-Table Name, FullName, Length
          } else {
              Write-Host "‚ùå desktop-ce directory does not exist!"
              Write-Host "Looking for any build directories..."
              Get-ChildItem -Path . | Format-Table Name, FullName
          }
          Write-Host ""
          Write-Host "üîç Looking for .exe files anywhere:"
          Get-ChildItem -Path . -Filter "*.exe" -Recurse -ErrorAction SilentlyContinue | Format-Table Name, FullName, Length

      - name: Verify Windows SDK tools
        shell: pwsh
        run: |
          Write-Host "üîß Checking for Windows SDK tools..."

          # Check for makeappx
          $makeappx = Get-Command makeappx -ErrorAction SilentlyContinue
          if ($makeappx) {
              Write-Host "‚úÖ makeappx found at: $($makeappx.Path)"
          } else {
              Write-Host "‚ö†Ô∏è makeappx not found in PATH, will search Windows SDK locations"
              $sdkPaths = @(
                  "C:\Program Files (x86)\Windows Kits\10\bin\*\x64\makeappx.exe"
              )
              $found = Get-ChildItem -Path $sdkPaths -ErrorAction SilentlyContinue | Select-Object -First 1
              if ($found) {
                  Write-Host "‚úÖ Found makeappx at: $($found.FullName)"
                  # Add to PATH for this session
                  $env:PATH = "$($found.DirectoryName);$env:PATH"
              } else {
                  Write-Host "‚ùå makeappx not found - MSIX build may fail"
              }
          }

      - name: Build unsigned MSIX for Microsoft Store
        shell: pwsh
        run: |
          if ("${{ needs.calculate-version.outputs.dry_run }}" -eq "true") {
            echo "üèÉ DRY RUN MODE - Building unsigned MSIX package (will not publish)"
          } else {
            echo "üì¶ Building unsigned MSIX package for Microsoft Store"
          }
          echo "‚ÑπÔ∏è Microsoft will sign this package when uploaded to Partner Center"

          # Ensure Windows SDK tools are in PATH
          $sdkPath = Get-ChildItem -Path "C:\Program Files (x86)\Windows Kits\10\bin\*\x64" -Directory -ErrorAction SilentlyContinue | Select-Object -First 1
          if ($sdkPath) {
              $env:PATH = "$($sdkPath.FullName);$env:PATH"
              Write-Host "Added Windows SDK tools to PATH: $($sdkPath.FullName)"
          }

          # Build unsigned MSIX package (Microsoft will sign it)
          .\scripts\build-msix.ps1 -Architecture amd64 -Version ${{ needs.calculate-version.outputs.version }} -SkipSigning

      # ARM64 build temporarily disabled
      # - name: Build MSIX arm64
      #   if: needs.calculate-version.outputs.dry_run == 'false'
      #   shell: pwsh
      #   env:
      #     WINDOWS_PFX_PASSWORD: ${{ secrets.WINDOWS_PFX_PASSWORD }}
      #   run: |
      #     .\scripts\build-msix.ps1 -Architecture arm64 -Version ${{ needs.calculate-version.outputs.version }} -PublisherCN "${{ secrets.WINDOWS_PUBLISHER_CN }}" -CertPath cert.pfx

      - name: Create MSIX bundle (AMD64 only for now)
        shell: pwsh
        run: |
          # Since we only have AMD64 for now, rename it as the bundle
          Move-Item "WhoDB-${{ needs.calculate-version.outputs.version }}-amd64.msix" "WhoDB-${{ needs.calculate-version.outputs.version }}.msixbundle" -Force

      - name: Upload MSIX artifacts
        uses: actions/upload-artifact@v4
        with:
          name: windows-msix
          path: WhoDB-*.msixbundle
          retention-days: 1

  build-snap:
    name: Build Snap Package
    strategy:
      matrix:
        include:
          - runner: ubuntu-latest
            arch: amd64
          - runner: ubuntu-24.04-arm
            arch: arm64
    runs-on: ${{ matrix.runner }}
    needs: [ calculate-version ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Prepare snap build
        run: |
          # Copy the CE snapcraft file to the expected location
          cp snapcraft-ce.yaml snapcraft.yaml

      - name: Build snap from source
        uses: snapcore/action-build@v1
        id: build

      - name: Rename snap with architecture
        run: |
          SNAP_FILE="${{ steps.build.outputs.snap }}"
          NEW_NAME="${SNAP_FILE%.snap}_${{ matrix.arch }}.snap"
          mv "$SNAP_FILE" "$NEW_NAME"
          echo "SNAP_FILE=$NEW_NAME" >> $GITHUB_ENV

      - name: Upload snap artifact
        uses: actions/upload-artifact@v4
        with:
          name: snap-package-${{ matrix.arch }}
          path: ${{ env.SNAP_FILE }}
          retention-days: 1


  sign-with-sigstore:
    name: Sign Artifacts with Sigstore
    runs-on: ubuntu-latest
    needs: [ calculate-version, package-windows-msix, package-mac-app-store, build-snap, build-desktop-ce ]
    # Need write permissions for OIDC token
    permissions:
      contents: write
      id-token: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Install Cosign
        uses: sigstore/cosign-installer@v3

      - name: Download all artifacts
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
        # Continue even if dockerbuild metadata artifacts fail to download
        continue-on-error: true

      - name: Sign Windows MSIX bundle
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          for file in artifacts/windows-msix/*.msixbundle; do
            if [ -f "$file" ]; then
              echo "Signing $file with Sigstore..."
              cosign sign-blob --yes "$file" \
                --output-signature="${file}.sig" \
                --output-certificate="${file}.pem" \
                --oidc-issuer=https://token.actions.githubusercontent.com \
                || echo "Warning: Failed to sign $file, continuing..."
            fi
          done

      - name: Sign Mac App Store package
        env:
          COSIGN_EXPERIMENTAL: 1
        run: |
          for file in artifacts/mac-app-store/*.pkg; do
            if [ -f "$file" ]; then
              echo "Signing $file with Sigstore..."
              cosign sign-blob --yes "$file" \
                --output-signature="${file}.sig" \
                --output-certificate="${file}.pem" \
                --oidc-issuer=https://token.actions.githubusercontent.com \
                || echo "Warning: Failed to sign $file, continuing..."
            fi
          done

      - name: Upload signed artifacts
        uses: actions/upload-artifact@v4
        with:
          name: signed-artifacts
          path: artifacts/
          retention-days: 1

  validate-all-builds:
    name: Validate All Builds
    runs-on: ubuntu-latest
    needs: [ sign-with-sigstore, build-docker-ce, calculate-version ]
    steps:
      - name: Checkout for scripts
        uses: actions/checkout@v4

      - name: Download required artifacts for validation
        uses: actions/download-artifact@v4
        with:
          path: artifacts/
        # Continue even if dockerbuild metadata artifacts fail
        continue-on-error: true

      - name: Clean up Docker metadata artifacts
        run: |
          # Remove any dockerbuild artifacts that may have partially downloaded
          rm -rf artifacts/*dockerbuild* || true
          echo "Cleaned up Docker metadata artifacts (not required for validation)"

      - name: Validate artifacts
        run: |
          echo "Checking for required artifacts..."
          [ -f "artifacts/docker-image-amd64/whodb-docker-amd64.tar" ] || (echo "Docker amd64 image missing" && exit 1)
          [ -f "artifacts/docker-image-arm64/whodb-docker-arm64.tar" ] || (echo "Docker arm64 image missing" && exit 1)
          [ -f "artifacts/windows-msix/"*.msixbundle ] || (echo "Windows MSIX bundle missing" && exit 1)
          [ -f "artifacts/mac-app-store/"*.pkg ] || (echo "Mac App Store package missing" && exit 1)
          [ -f "artifacts/snap-package-amd64/"*.snap ] || (echo "Snap amd64 package missing" && exit 1)
          [ -f "artifacts/snap-package-arm64/"*.snap ] || (echo "Snap arm64 package missing" && exit 1)
          echo "‚úì All required artifacts present"
          echo "Note: Windows ARM64 build is temporarily disabled"

      - name: Initialize deployment manifest
        run: |
          bash scripts/track-deployment.sh docker pending ${{ needs.calculate-version.outputs.version }}

      - name: Upload deployment manifest
        uses: actions/upload-artifact@v4
        with:
          name: deployment-manifest
          path: deployment_manifest.json
          retention-days: 1

  # Deploy to stores first (these can be reviewed/rolled back before going live)
  deploy-snap:
    name: Deploy to Snap Store
    runs-on: ubuntu-latest
    needs: [ calculate-version, validate-all-builds ]
    steps:
      - name: Checkout for scripts
        uses: actions/checkout@v4

      - name: Check Snapcraft credentials
        run: |
          echo "üîç Checking Snapcraft credentials..."
          if [ -n "${{ secrets.SNAPCRAFT_STORE_CREDENTIALS }}" ]; then
            echo "  ‚úÖ SNAPCRAFT_STORE_CREDENTIALS is configured"
          else
            echo "  ‚ùå SNAPCRAFT_STORE_CREDENTIALS is NOT configured"
            if [ "${{ needs.calculate-version.outputs.dry_run }}" = "false" ]; then
              echo "::error::Production deployment requires SNAPCRAFT_STORE_CREDENTIALS"
              exit 1
            fi
          fi

      - name: Download snap amd64 artifact
        uses: actions/download-artifact@v4
        with:
          name: snap-package-amd64

      - name: Download snap arm64 artifact
        uses: actions/download-artifact@v4
        with:
          name: snap-package-arm64

      - name: Download deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest
          path: .

      - name: Capture current Snap Store state
        if: needs.calculate-version.outputs.dry_run == 'false'
        env:
          SNAPCRAFT_STORE_CREDENTIALS: ${{ secrets.SNAPCRAFT_STORE_CREDENTIALS }}
        run: |
          bash scripts/capture-store-state.sh whodb

      - name: Publish to Snap Store
        if: needs.calculate-version.outputs.dry_run == 'false'
        env:
          SNAPCRAFT_STORE_CREDENTIALS: ${{ secrets.SNAPCRAFT_STORE_CREDENTIALS }}
        run: |
          # Snap Store automatically handles multi-arch packages when uploaded separately
          for snap in *.snap; do
            echo "Publishing $snap to Snap Store..."
            snapcraft upload "$snap" --release=stable
          done

      - name: Track Snap deployment
        if: needs.calculate-version.outputs.dry_run == 'false'
        run: |
          bash scripts/track-deployment.sh snap deployed ${{ needs.calculate-version.outputs.version }}

      - name: Dry run summary
        if: needs.calculate-version.outputs.dry_run == 'true'
        run: |
          echo "üèÉ DRY RUN MODE - Would have published:"
          echo "  - Snap packages (amd64 and arm64) to stable channel"
          ls -lh *.snap

      - name: Upload updated manifest
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-manifest-snap
          path: deployment_manifest.json
          retention-days: 1

      - name: Upload store state
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: store-state
          path: store_state.json
          retention-days: 1

  deploy-microsoft-store:
    name: Deploy to Microsoft Store
    runs-on: windows-latest
    needs: [ calculate-version, package-windows-msix, deploy-snap ]
    if: needs.calculate-version.outputs.dry_run == 'false'
    steps:
      - name: Checkout for scripts
        uses: actions/checkout@v4

      - name: Check Microsoft Store credentials
        shell: pwsh
        run: |
          Write-Host "üîç Checking Microsoft Store credentials..."

          if ("${{ secrets.MS_TENANT_ID }}" -ne "") {
            Write-Host "  ‚úÖ MS_TENANT_ID is configured"
          } else {
            Write-Host "  ‚ùå MS_TENANT_ID is NOT configured"
          }

          if ("${{ secrets.MS_CLIENT_ID }}" -ne "") {
            Write-Host "  ‚úÖ MS_CLIENT_ID is configured"
          } else {
            Write-Host "  ‚ùå MS_CLIENT_ID is NOT configured"
          }

          if ("${{ secrets.MS_CLIENT_SECRET }}" -ne "") {
            Write-Host "  ‚úÖ MS_CLIENT_SECRET is configured"
          } else {
            Write-Host "  ‚ùå MS_CLIENT_SECRET is NOT configured"
          }

          if ("${{ secrets.MS_APP_ID }}" -ne "") {
            Write-Host "  ‚úÖ MS_APP_ID is configured"
          } else {
            Write-Host "  ‚ùå MS_APP_ID is NOT configured"
          }

          $allConfigured = ("${{ secrets.MS_TENANT_ID }}" -ne "") -and
                          ("${{ secrets.MS_CLIENT_ID }}" -ne "") -and
                          ("${{ secrets.MS_CLIENT_SECRET }}" -ne "") -and
                          ("${{ secrets.MS_APP_ID }}" -ne "")

          if ($allConfigured) {
            Write-Host "‚úÖ All Microsoft Store credentials are configured"
          } else {
            Write-Host "‚ö†Ô∏è Some Microsoft Store credentials are missing"
            Write-Host "::warning::Microsoft Store deployment may fail due to missing credentials"
          }

      - name: Download MSIX package
        uses: actions/download-artifact@v4
        with:
          name: windows-msix
          path: .

      - name: Download deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest-snap
          path: .

      - name: Setup Microsoft Store CLI
        shell: pwsh
        run: |
          # Install Windows Store CLI tools
          Install-Module -Name StoreBroker -Force -Scope CurrentUser
          Import-Module StoreBroker

      - name: Authenticate to Microsoft Store
        shell: pwsh
        env:
          MS_TENANT_ID: ${{ secrets.MS_TENANT_ID }}
          MS_CLIENT_ID: ${{ secrets.MS_CLIENT_ID }}
          MS_CLIENT_SECRET: ${{ secrets.MS_CLIENT_SECRET }}
        run: |
          $securePassword = ConvertTo-SecureString $env:MS_CLIENT_SECRET -AsPlainText -Force
          $credential = New-Object System.Management.Automation.PSCredential($env:MS_CLIENT_ID, $securePassword)

          # Authenticate to Partner Center
          Set-StoreBrokerAuthentication -TenantId $env:MS_TENANT_ID -Credential $credential

      - name: Create and submit Microsoft Store submission
        shell: pwsh
        env:
          MS_APP_ID: ${{ secrets.MS_APP_ID }}
        run: |
          $appId = $env:MS_APP_ID
          $msixPath = Get-ChildItem -Path "." -Filter "*.msixbundle" | Select-Object -First 1

          # Create new submission
          $submission = New-ApplicationSubmission -AppId $appId -Force

          # Update submission with new package
          Update-ApplicationSubmission -AppId $appId -SubmissionDataPath $submission -PackagePath $msixPath.FullName

          # Submit to Store (as draft initially)
          $submissionId = Submit-ApplicationSubmission -AppId $appId -SubmissionDataPath $submission -TargetPublishMode Immediate

          Write-Host "Submission created with ID: $submissionId"
          Write-Host "Check Partner Center to review and publish the submission"

      - name: Upload updated manifest
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-manifest-msstore
          path: deployment_manifest.json
          retention-days: 1

  deploy-apple-store:
    name: Deploy to Apple App Store
    runs-on: macos-latest
    needs: [ calculate-version, package-mac-app-store, deploy-snap ]
    if: needs.calculate-version.outputs.dry_run == 'false'
    steps:
      - name: Checkout for scripts
        uses: actions/checkout@v4

      - name: Check Apple Store credentials
        run: |
          echo "üîç Checking Apple Store credentials..."

          if [ -n "${{ secrets.APP_STORE_CONNECT_API_KEY }}" ]; then
            echo "  ‚úÖ APP_STORE_CONNECT_API_KEY is configured"
          else
            echo "  ‚ùå APP_STORE_CONNECT_API_KEY is NOT configured"
          fi

          if [ -n "${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}" ]; then
            echo "  ‚úÖ APP_STORE_CONNECT_API_KEY_ID is configured"
          else
            echo "  ‚ùå APP_STORE_CONNECT_API_KEY_ID is NOT configured"
          fi

          if [ -n "${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}" ]; then
            echo "  ‚úÖ APP_STORE_CONNECT_ISSUER_ID is configured"
          else
            echo "  ‚ùå APP_STORE_CONNECT_ISSUER_ID is NOT configured"
          fi

          if [ -n "${{ secrets.APPLE_ID }}" ]; then
            echo "  ‚úÖ APPLE_ID is configured"
          else
            echo "  ‚ùå APPLE_ID is NOT configured"
          fi

          if [ -n "${{ secrets.APP_STORE_CONNECT_API_KEY }}" ] && [ -n "${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}" ] && [ -n "${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}" ]; then
            echo "‚úÖ All Apple Store credentials are configured"
          else
            echo "‚ö†Ô∏è Some Apple Store credentials are missing"
            echo "::warning::Apple Store deployment may fail due to missing credentials"
          fi

      - name: Download Mac App Store package
        uses: actions/download-artifact@v4
        with:
          name: mac-app-store
          path: .

      - name: Download deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest-snap
          path: .
        continue-on-error: true

      - name: Setup App Store Connect API Key
        env:
          APP_STORE_CONNECT_API_KEY: ${{ secrets.APP_STORE_CONNECT_API_KEY }}
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          # Create private keys directory
          mkdir -p ~/.appstoreconnect/private_keys

          # Save API key
          echo "$APP_STORE_CONNECT_API_KEY" > ~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8

          # Set proper permissions
          chmod 600 ~/.appstoreconnect/private_keys/AuthKey_${APP_STORE_CONNECT_API_KEY_ID}.p8

      - name: Upload to App Store Connect
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
          APPLE_ID: ${{ secrets.APPLE_ID }}
        run: |
          # Find the .pkg file
          PKG_FILE=$(find . -name "*.pkg" -type f | head -1)

          echo "Uploading $PKG_FILE to App Store Connect..."

          # Upload using Transporter (altool is deprecated)
          xcrun iTMSTransporter -m upload \
            -assetFile "$PKG_FILE" \
            -apiKey "$APP_STORE_CONNECT_API_KEY_ID" \
            -apiIssuer "$APP_STORE_CONNECT_ISSUER_ID" \
            -v detailed \
            -verboseLogging

          echo "‚úÖ Package uploaded to App Store Connect"
          echo "üìù Review and submit for review in App Store Connect"

      - name: Create TestFlight release (optional)
        env:
          APP_STORE_CONNECT_API_KEY_ID: ${{ secrets.APP_STORE_CONNECT_API_KEY_ID }}
          APP_STORE_CONNECT_ISSUER_ID: ${{ secrets.APP_STORE_CONNECT_ISSUER_ID }}
        run: |
          echo "Package is now available in App Store Connect for TestFlight distribution"
          echo "Manual review and release required via App Store Connect dashboard"

      - name: Upload updated manifest
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-manifest-appstore
          path: deployment_manifest.json
          retention-days: 1

  # Create GitHub release after stores are deployed
  create-github-release:
    name: Create GitHub Release
    runs-on: ubuntu-latest
    needs: [ calculate-version, deploy-snap, deploy-microsoft-store, deploy-apple-store ]
    permissions:
      contents: write
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest-snap
          path: .
        continue-on-error: true

      - name: Download all signed artifacts
        uses: actions/download-artifact@v4
        with:
          name: signed-artifacts
          path: release-assets/

      - name: Prepare release assets
        run: |
          mkdir -p final-assets

          # Copy Windows MSIX bundle (for users who prefer direct download)
          cp release-assets/windows-msix/*.msixbundle final-assets/ || true
          cp release-assets/windows-msix/*.sig final-assets/ || true

          # Copy Mac App Store package (for users who prefer direct download)
          cp release-assets/mac-app-store/*.pkg final-assets/ || true
          cp release-assets/mac-app-store/*.sig final-assets/ || true

      - name: Generate checksums
        working-directory: final-assets
        run: |
          sha256sum * > SHA256SUMS.txt

      - name: Create Release
        id: create_release
        if: needs.calculate-version.outputs.dry_run == 'false'
        uses: softprops/action-gh-release@v2
        with:
          tag_name: v${{ needs.calculate-version.outputs.version }}
          name: Release v${{ needs.calculate-version.outputs.version }}
          body: |
            # WhoDB v${{ needs.calculate-version.outputs.version }}

            ## Docker Images
            - `docker pull clidey/whodb:${{ needs.calculate-version.outputs.version }}`
            - `docker pull clidey/whodb:latest`

            ## Installation

            **Snap:**
            ```bash
            sudo snap install whodb
            ```

            **Flatpak:**
            Available on [Flathub](https://flathub.org/apps/com.clidey.whodb)

            **Windows:**
            Available on Microsoft Store

            **macOS:**
            Available on Mac App Store

            ## Release Notes
            [TODO: Add release notes here]

            ## Verification
            All binaries are signed with Sigstore. Verify signatures using cosign:
            ```bash
            cosign verify-blob --signature <file>.sig --certificate <file>.pem <file>
            ```
          files: final-assets/*
          draft: false
          prerelease: false

      - name: Track GitHub release
        if: needs.calculate-version.outputs.dry_run == 'false'
        run: |
          bash scripts/track-deployment.sh github_release deployed ${{ needs.calculate-version.outputs.version }} "${{ steps.create_release.outputs.id }}"

      - name: Dry run summary
        if: needs.calculate-version.outputs.dry_run == 'true'
        run: |
          echo "üèÉ DRY RUN MODE - Would have created GitHub release:"
          echo "  - Tag: v${{ needs.calculate-version.outputs.version }}"
          echo "  - Files:"
          ls -lh final-assets/

      - name: Upload updated manifest
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-manifest-github
          path: deployment_manifest.json
          retention-days: 1

  # Deploy Docker images last (hardest to rollback)
  deploy-docker:
    name: Deploy Docker Images
    runs-on: ubuntu-latest
    needs: [ calculate-version, create-github-release ]
    steps:
      - name: Checkout for scripts
        uses: actions/checkout@v4

      - name: Check Docker Hub credentials
        run: |
          echo "üîç Checking Docker Hub credentials..."

          if [ -n "${{ secrets.DOCKERHUB_USERNAME }}" ]; then
            echo "  ‚úÖ DOCKERHUB_USERNAME is configured"
          else
            echo "  ‚ùå DOCKERHUB_USERNAME is NOT configured"
          fi

          if [ -n "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
            echo "  ‚úÖ DOCKERHUB_TOKEN is configured"
          else
            echo "  ‚ùå DOCKERHUB_TOKEN is NOT configured"
          fi

          if [ -n "${{ secrets.DOCKERHUB_USERNAME }}" ] && [ -n "${{ secrets.DOCKERHUB_TOKEN }}" ]; then
            echo "‚úÖ All Docker Hub credentials are configured"
          else
            echo "‚ùå Docker Hub credentials are missing"
            if [ "${{ needs.calculate-version.outputs.dry_run }}" = "false" ]; then
              echo "::error::Production deployment requires Docker Hub credentials"
              exit 1
            fi
          fi

      - name: Download Docker amd64 artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-amd64
          path: /tmp

      - name: Download Docker arm64 artifact
        uses: actions/download-artifact@v4
        with:
          name: docker-image-arm64
          path: /tmp

      - name: Download deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest-github
          path: .

      - name: Load Docker images
        run: |
          docker load --input /tmp/whodb-docker-amd64.tar
          docker load --input /tmp/whodb-docker-arm64.tar

      - name: Login to Docker Hub
        uses: docker/login-action@v3
        with:
          username: ${{ secrets.DOCKERHUB_USERNAME }}
          password: ${{ secrets.DOCKERHUB_TOKEN }}

      - name: Install Cosign
        if: needs.calculate-version.outputs.dry_run == 'false'
        uses: sigstore/cosign-installer@v3

      - name: Set up Docker Buildx for manifest
        uses: docker/setup-buildx-action@v3

      - name: Push Docker images and create manifest
        if: needs.calculate-version.outputs.dry_run == 'false'
        run: |
          # Push individual platform images
          docker push clidey/whodb:${{ needs.calculate-version.outputs.version }}-amd64 || exit 1
          docker push clidey/whodb:${{ needs.calculate-version.outputs.version }}-arm64 || exit 1

          # Create and push multi-platform manifests
          docker buildx imagetools create -t clidey/whodb:${{ needs.calculate-version.outputs.version }} \
            clidey/whodb:${{ needs.calculate-version.outputs.version }}-amd64 \
            clidey/whodb:${{ needs.calculate-version.outputs.version }}-arm64

          docker buildx imagetools create -t clidey/whodb:latest \
            clidey/whodb:${{ needs.calculate-version.outputs.version }}-amd64 \
            clidey/whodb:${{ needs.calculate-version.outputs.version }}-arm64

          bash scripts/track-deployment.sh docker deployed ${{ needs.calculate-version.outputs.version }}

      - name: Sign Docker images
        if: needs.calculate-version.outputs.dry_run == 'false'
        run: |
          cosign sign --yes clidey/whodb:${{ needs.calculate-version.outputs.version }}
          cosign sign --yes clidey/whodb:latest

      - name: Dry run summary
        if: needs.calculate-version.outputs.dry_run == 'true'
        run: |
          echo "üèÉ DRY RUN MODE"
          echo "‚úÖ Successfully logged in to Docker Hub"
          echo "üì¶ Would have pushed:"
          echo "  - clidey/whodb:${{ needs.calculate-version.outputs.version }}"
          echo "  - clidey/whodb:latest"
          echo "üîè Would have signed both images with Sigstore"

      - name: Upload updated manifest
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: deployment-manifest-docker
          path: deployment_manifest.json
          retention-days: 1

  rollback:
    name: Rollback on Failure
    runs-on: ubuntu-latest
    if: failure() && needs.calculate-version.outputs.dry_run == 'false'
    needs: [ calculate-version, deploy-docker, create-github-release, deploy-snap, deploy-microsoft-store, deploy-apple-store ]
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest-docker
          path: .
        continue-on-error: true

      - name: Download store state
        uses: actions/download-artifact@v4
        with:
          name: store-state
          path: .
        continue-on-error: true

      - name: Enhanced comprehensive rollback
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
          SNAPCRAFT_STORE_CREDENTIALS: ${{ secrets.SNAPCRAFT_STORE_CREDENTIALS }}
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          GITHUB_REPOSITORY: ${{ github.repository }}
          MS_TENANT_ID: ${{ secrets.MS_TENANT_ID }}
          MS_CLIENT_ID: ${{ secrets.MS_CLIENT_ID }}
          MS_CLIENT_SECRET: ${{ secrets.MS_CLIENT_SECRET }}
          MS_APP_ID: ${{ secrets.MS_APP_ID }}
        run: |
          bash scripts/rollback-all.sh \
            ${{ needs.calculate-version.outputs.version }} \
            ${{ needs.calculate-version.outputs.previous_version }} \
            deployment_manifest.json \
            store_state.json

      - name: Notify rollback
        run: |
          echo "::error::Deployment failed and has been rolled back"
          echo "Failed version: ${{ needs.calculate-version.outputs.version }}"
          echo "Reverted to: ${{ needs.calculate-version.outputs.previous_version }}"
          echo ""
          echo "Rollback actions taken:"
          echo "  - Docker: Reverted latest tag to ${{ needs.calculate-version.outputs.previous_version }}"
          echo "  - Docker: Deleted tag ${{ needs.calculate-version.outputs.version }}"
          echo "  - Snap: Manual verification required in Snapcraft dashboard"
          echo "  - GitHub: Release and tag deleted if they existed"
          exit 1

  verify-deployment:
    name: Verify Deployment Success
    runs-on: ubuntu-latest
    needs: [ calculate-version, deploy-docker ]
    if: needs.calculate-version.outputs.dry_run == 'false'
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Download final deployment manifest
        uses: actions/download-artifact@v4
        with:
          name: deployment-manifest-docker
          path: .

      - name: Verify all deployments successful
        run: |
          echo "Verifying deployment status..."

          DOCKER_STATUS=$(jq -r '.docker.status' deployment_manifest.json)
          SNAP_STATUS=$(jq -r '.snap.status' deployment_manifest.json)
          GITHUB_STATUS=$(jq -r '.github_release.status' deployment_manifest.json)

          echo "Docker deployment: $DOCKER_STATUS"
          echo "Snap deployment: $SNAP_STATUS"
          echo "GitHub release: $GITHUB_STATUS"

          if [ "$DOCKER_STATUS" != "deployed" ] || [ "$SNAP_STATUS" != "deployed" ] || [ "$GITHUB_STATUS" != "deployed" ]; then
            echo "::error::Not all deployments completed successfully"
            exit 1
          fi

          echo "‚úì All deployments verified successful"

      - name: Test Docker image availability
        run: |
          echo "Testing Docker image pull..."
          docker pull clidey/whodb:${{ needs.calculate-version.outputs.version }} || exit 1
          echo "‚úì Docker image is accessible"

      - name: Verify GitHub release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          echo "Verifying GitHub release..."
          RELEASE_URL="https://api.github.com/repos/${{ github.repository }}/releases/tags/v${{ needs.calculate-version.outputs.version }}"
          RELEASE_STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: token $GITHUB_TOKEN" "$RELEASE_URL")

          if [ "$RELEASE_STATUS" != "200" ]; then
            echo "::error::GitHub release not found (HTTP $RELEASE_STATUS)"
            exit 1
          fi

          echo "‚úì GitHub release verified"