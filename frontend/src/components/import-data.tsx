/*
 * Copyright 2026 Clidey, Inc.
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

import {
  Button,
  Checkbox,
  Input,
  Label,
  Select,
  SelectContent,
  SelectItem,
  SelectTrigger,
  SelectValue,
  Sheet,
  SheetContent,
  SheetFooter,
  SheetTitle,
  toast,
} from "@clidey/ux";
import {FC, useCallback, useEffect, useMemo, useRef, useState} from "react";
import {useTranslation} from "@/hooks/use-translation";
import {CodeEditor} from "@/components/editor";
import {executeMultipartGraphQL} from "@/utils/graphql-upload";
import {addAuthHeader} from "@/utils/auth-headers";
import {print} from "graphql";
import {
  ImportFileFormat,
  ImportFileOptions,
  ImportMode,
  ImportPreviewDocument,
  ImportPreviewMutation,
  ImportSqlDocument,
  ImportSqlMutation,
  ImportTableFileDocument,
  ImportTableFileMutation,
} from "@graphql";

const importLimits = {
  maxRows: 100000,
  maxFileSizeBytes: 50 * 1024 * 1024,
} as const;

type ImportModeType = "data" | "sql";
type DataFormatType = "csv" | "excel";
const previewRowLimit = 3;
const previewMinDelayMs = 1000;

type ImportDataProps = {
  open: boolean;
  onOpenChange: (open: boolean) => void;
  schema: string;
  storageUnit: string;
  columns: string[];
  onImportSuccess?: () => void;
};

type PreviewMapping = NonNullable<ImportPreviewMutation["ImportPreview"]["Mapping"]>;

/**
 * ImportData provides SQL and CSV/XLSX import workflows with automatic mapping.
 */
export const ImportData: FC<ImportDataProps> = ({
  open,
  onOpenChange,
  schema,
  storageUnit,
  onImportSuccess,
}) => {
  const { t } = useTranslation("components/import-data");
  const importSizeMB = Math.round(importLimits.maxFileSizeBytes / (1024 * 1024));
  const [mode, setMode] = useState<ImportModeType>("data");

  const [dataFormat, setDataFormat] = useState<DataFormatType>("csv");
  const [dataFile, setDataFile] = useState<File | null>(null);
  const [delimiter, setDelimiter] = useState("auto");
  const [preview, setPreview] = useState<ImportPreviewMutation["ImportPreview"] | null>(null);
  const [previewMapping, setPreviewMapping] = useState<PreviewMapping | null>(null);
  const [allowAutoGenerated, setAllowAutoGenerated] = useState(false);
  const [previewRequiresAutoGenerated, setPreviewRequiresAutoGenerated] = useState(false);
  const [previewAutoGeneratedColumns, setPreviewAutoGeneratedColumns] = useState<string[]>([]);
  const [detectedSheet, setDetectedSheet] = useState<string | null>(null);
  const [previewError, setPreviewError] = useState<string | null>(null);
  const [previewValidationError, setPreviewValidationError] = useState<string | null>(null);
  const [dataMode, setDataMode] = useState<ImportMode>(ImportMode.Append);
  const [loadingPreview, setLoadingPreview] = useState(false);
  const [loadingImport, setLoadingImport] = useState(false);

  const [sqlFile, setSqlFile] = useState<File | null>(null);
  const [sqlText, setSqlText] = useState("");
  const [loadingSQL, setLoadingSQL] = useState(false);
  const [sqlConfirmed, setSqlConfirmed] = useState(false);

  const isAutoGeneratedValidation = previewValidationError === "import.validation.auto_generated_requires_toggle";
  const autoGeneratedBlocked = previewRequiresAutoGenerated && !allowAutoGenerated;
  const autoGeneratedBlockMessage = t("import.validation.auto_generated_requires_toggle");
  const translateKey = (key?: string | null) => (key ? t(key, { defaultValue: key }) : null);
  const validationMessage = previewValidationError ? translateKey(previewValidationError) : null;
  const blockingValidationMessage =
    validationMessage && !isAutoGeneratedValidation && !(previewRequiresAutoGenerated && allowAutoGenerated)
      ? validationMessage
      : null;
  const previewErrorMessage = translateKey(previewError);

  const delimiterOptions = useMemo(
    () => [
      { value: "auto", label: t("delimiterAuto") },
      { value: ",", label: t("delimiterComma") },
      { value: ";", label: t("delimiterSemicolon") },
      { value: "|", label: t("delimiterPipe") },
    ],
    [t],
  );

  const importModeOptions = useMemo(
    () => [
      { value: ImportMode.Append, label: t("modeAppend") },
      { value: ImportMode.Overwrite, label: t("modeOverwrite") },
    ],
    [t],
  );

  const previewRequestId = useRef(0);
  const lastPreviewKey = useRef<string | null>(null);

  const resetDataState = useCallback(() => {
    setDataFile(null);
    setDelimiter("auto");
    setPreview(null);
    setPreviewMapping(null);
    setAllowAutoGenerated(false);
    setPreviewRequiresAutoGenerated(false);
    setPreviewAutoGeneratedColumns([]);
    setDetectedSheet(null);
    setPreviewError(null);
    setPreviewValidationError(null);
    setDataMode(ImportMode.Append);
    setLoadingPreview(false);
    setLoadingImport(false);
    lastPreviewKey.current = null;
  }, []);

  const resetSQLState = useCallback(() => {
    setSqlFile(null);
    setSqlText("");
    setLoadingSQL(false);
    setSqlConfirmed(false);
  }, []);

  const detectDataFormat = useCallback((file: File): DataFormatType | null => {
    const name = file.name.toLowerCase().trim();
    if (name.endsWith(".csv")) {
      return "csv";
    }
    if (name.endsWith(".xlsx") || name.endsWith(".xlsm")) {
      return "excel";
    }

    const mime = file.type.toLowerCase();
    if (mime === "text/csv") {
      return "csv";
    }
    if (
      mime === "application/vnd.openxmlformats-officedocument.spreadsheetml.sheet" ||
      mime === "application/vnd.ms-excel.sheet.macroenabled.12"
    ) {
      return "excel";
    }

    return null;
  }, []);

  useEffect(() => {
    if (!open) {
      resetDataState();
      resetSQLState();
      setMode("data");
    }
  }, [open, resetDataState, resetSQLState]);

  useEffect(() => {
    setAllowAutoGenerated(false);
  }, [dataFile]);

  const buildOptions = useCallback((): ImportFileOptions => {
    if (dataFormat === "csv") {
      const csvOptions: ImportFileOptions = {
        Format: ImportFileFormat.Csv,
      };
      if (delimiter !== "auto") {
        csvOptions.Delimiter = delimiter;
      }
      return csvOptions;
    }

    return {
      Format: ImportFileFormat.Excel,
    };
  }, [dataFormat, delimiter]);

  const loadPreview = useCallback(async () => {
    if (!dataFile) {
      return;
    }
    const nextKey = `${dataFile.name}:${dataFile.size}:${dataFile.lastModified}:${dataFormat}:${delimiter}`;
    if (lastPreviewKey.current === nextKey) {
      return;
    }
    lastPreviewKey.current = nextKey;
    const requestId = previewRequestId.current + 1;
    previewRequestId.current = requestId;
    setLoadingPreview(true);
    setPreviewError(null);
    setPreviewValidationError(null);
    const delayPromise = new Promise((resolve) => {
      setTimeout(resolve, previewMinDelayMs);
    });

    let nextPreview: ImportPreviewMutation["ImportPreview"] | null = null;
    let nextSheet: string | null = null;
    let nextError: string | null = null;
    let nextValidationError: string | null = null;
    let nextMapping: PreviewMapping | null = null;
    let nextRequiresAutoGenerated = false;
    let nextAutoGeneratedColumns: string[] = [];
    try {
      const finalPreview = await executeMultipartGraphQL<ImportPreviewMutation>({
        query: print(ImportPreviewDocument),
        variables: {
          file: null,
          options: buildOptions(),
          schema,
          storageUnit,
          useHeaderMapping: true,
        },
        file: dataFile,
        filePath: "variables.file",
        operationName: "ImportPreview",
      });

      const previewResult = finalPreview.ImportPreview;
      nextValidationError = previewResult.ValidationError ?? null;
      const shouldKeepMapping = previewResult.ValidationError === "import.validation.auto_generated_requires_toggle";
      nextMapping = previewResult.ValidationError && !shouldKeepMapping ? null : previewResult.Mapping ?? null;
      nextRequiresAutoGenerated = previewResult.RequiresAllowAutoGenerated ?? false;
      nextAutoGeneratedColumns = previewResult.AutoGeneratedColumns ?? [];
      nextSheet = previewResult.Sheet ?? null;
      nextPreview = previewResult;
    } catch (error: any) {
      nextError = error.message || t("unknownError");
    }

    await delayPromise;
    if (previewRequestId.current !== requestId) {
      return;
    }
    if (nextError) {
      setPreview(null);
      setPreviewMapping(null);
      setPreviewRequiresAutoGenerated(false);
      setPreviewAutoGeneratedColumns([]);
      setPreviewError(nextError);
      setDetectedSheet(null);
      setPreviewValidationError(null);
    } else {
      setDetectedSheet(nextSheet);
      setPreviewValidationError(nextValidationError);
      setPreviewMapping(nextMapping);
      setPreviewRequiresAutoGenerated(nextRequiresAutoGenerated);
      setPreviewAutoGeneratedColumns(nextAutoGeneratedColumns);
      setPreview(nextPreview);
    }
    setLoadingPreview(false);
  }, [buildOptions, dataFile, dataFormat, delimiter, schema, storageUnit]);

  useEffect(() => {
    if (!open || !dataFile || mode !== "data") {
      return;
    }
    void loadPreview();
  }, [dataFile, dataFormat, delimiter, loadPreview, mode, open]);

  const handleImportData = useCallback(async () => {
    if (!dataFile || !preview) {
      toast.error(t("fileRequired"));
      return;
    }
    if (autoGeneratedBlocked) {
      toast.error(autoGeneratedBlockMessage);
      return;
    }
    if (!previewMapping || blockingValidationMessage) {
      const message = blockingValidationMessage ?? t("previewValidationMissing");
      toast.error(t("previewValidationFailed", { message }));
      return;
    }

    const options = buildOptions();
    if (dataFormat === "excel" && detectedSheet) {
      options.Sheet = detectedSheet;
    }
    const mappingInput = previewMapping.map((mapping) => ({
      SourceColumn: mapping.SourceColumn,
      TargetColumn: mapping.TargetColumn,
      Skip: false,
    }));

    setLoadingImport(true);
    try {
      const data = await executeMultipartGraphQL<ImportTableFileMutation>({
        query: print(ImportTableFileDocument),
        variables: {
          input: {
            Schema: schema,
            StorageUnit: storageUnit,
            Mode: dataMode,
            Options: options,
            File: null,
            Mapping: mappingInput,
            AllowAutoGenerated: allowAutoGenerated,
          },
        },
        file: dataFile,
        filePath: "variables.input.File",
        operationName: "ImportTableFile",
      });

      const result = data.ImportTableFile;
      if (result?.Status) {
        toast.success(t("importSuccess"));
        onOpenChange(false);
        onImportSuccess?.();
      } else {
        const message = translateKey(result?.Detail) ?? t("unknownError");
        toast.error(t("importFailed", { message }));
      }
    } catch (error: any) {
      toast.error(t("importFailed", { message: error.message || t("unknownError") }));
    } finally {
      setLoadingImport(false);
    }
  }, [
    buildOptions,
    dataFile,
    dataMode,
    detectedSheet,
    dataFormat,
    allowAutoGenerated,
    autoGeneratedBlocked,
    onImportSuccess,
    onOpenChange,
    preview,
    previewMapping,
    previewValidationError,
    schema,
    storageUnit,
    t,
  ]);

  const executeGraphQL = useCallback(async <T,>(query: string, variables: Record<string, any>) => {
    const response = await fetch("/api/query", {
      method: "POST",
      credentials: "include",
      headers: addAuthHeader({
        "Content-Type": "application/json",
      }),
      body: JSON.stringify({
        query,
        variables,
      }),
    });
    const result = await response.json();
    if (!response.ok || result.errors?.length) {
      const message = result.errors?.[0]?.message ?? "";
      throw new Error(message);
    }
    return result.data as T;
  }, []);

  const handleImportSQL = useCallback(async () => {
    const trimmedText = sqlText.trim();
    const hasFile = Boolean(sqlFile);
    const hasText = trimmedText.length > 0;

    if (hasFile && hasText) {
      toast.error(t("sqlSourceConflict"));
      return;
    }
    if (!hasFile && !hasText) {
      toast.error(t("sqlSourceRequired"));
      return;
    }

    setLoadingSQL(true);
    try {
      let data;
      if (sqlFile) {
        data = await executeMultipartGraphQL<ImportSqlMutation>({
          query: print(ImportSqlDocument),
          variables: {
            input: {
              File: null,
              Filename: sqlFile.name,
            },
          },
          file: sqlFile,
          filePath: "variables.input.File",
          operationName: "ImportSQL",
        });
      } else {
        data = await executeGraphQL<ImportSqlMutation>(print(ImportSqlDocument), {
          input: {
            Script: trimmedText,
            Filename: null,
          },
        });
      }
      const result = data.ImportSQL;
      if (result?.Status) {
        toast.success(t("importSuccess"));
        onOpenChange(false);
        onImportSuccess?.();
      } else {
        const message = translateKey(result?.Detail) ?? t("unknownError");
        toast.error(t("importFailed", { message }));
      }
    } catch (error: any) {
      toast.error(t("importFailed", { message: error.message || t("unknownError") }));
    } finally {
      setLoadingSQL(false);
    }
  }, [executeGraphQL, onImportSuccess, onOpenChange, sqlFile, sqlText, t]);

  const previewRows = useMemo(() => {
    if (!preview) {
      return [];
    }
    return preview.Rows.slice(0, previewRowLimit);
  }, [preview]);

  const previewIsTruncated = useMemo(() => {
    if (!preview) {
      return false;
    }
    return preview.Truncated || preview.Rows.length > previewRowLimit;
  }, [preview]);

  return (
    <Sheet open={open} onOpenChange={onOpenChange}>
      <SheetContent
        side="right"
        className="max-w-lg w-full p-8 flex flex-col h-full"
        data-testid="import-dialog"
      >
        <SheetTitle>{t("title")}</SheetTitle>
        <div className="flex-1 overflow-y-auto mt-4">
          <div className="flex flex-col gap-lg pr-2">
            <div className="space-y-4">
              <div className="space-y-2">
                <Label>{t("importType")}</Label>
                <Select value={mode} onValueChange={(value) => setMode(value as ImportModeType)}>
                  <SelectTrigger>
                    <SelectValue />
                  </SelectTrigger>
                  <SelectContent>
                    <SelectItem value="data">{t("modeData")}</SelectItem>
                    <SelectItem value="sql">{t("modeSql")}</SelectItem>
                  </SelectContent>
                </Select>
              </div>

              {mode === "data" ? (
                <>
                  <div className="space-y-2">
                    <Label>{t("dataFile")}</Label>
                    <Input
                      type="file"
                      accept=".csv,.xlsx,.xlsm"
                      onClick={(event) => {
                        (event.target as HTMLInputElement).value = "";
                      }}
                      onChange={(event) => {
                        const file = event.target.files?.[0] ?? null;
                        if (!file) {
                          lastPreviewKey.current = null;
                          setDataFile(null);
                          setPreview(null);
                          setDetectedSheet(null);
                          setPreviewError(null);
                          setPreviewValidationError(null);
                          return;
                        }

                        if (file.size > importLimits.maxFileSizeBytes) {
                          toast.error(t("fileTooLarge", { size: importSizeMB }));
                          event.target.value = "";
                          return;
                        }

                        const detected = detectDataFormat(file);
                        if (!detected) {
                          toast.error(t("fileTypeUnsupported"));
                          event.target.value = "";
                          lastPreviewKey.current = null;
                          setDataFile(null);
                          setPreview(null);
                          setDetectedSheet(null);
                          setPreviewError(null);
                          setPreviewValidationError(null);
                          return;
                        }

                        lastPreviewKey.current = null;
                        setDataFormat(detected);
                        setDataFile(file);
                        setPreview(null);
                        setDetectedSheet(null);
                        setPreviewError(null);
                        setPreviewValidationError(null);
                      }}
                    />
                    <p className="text-xs text-muted-foreground">
                      {t("fileLimits", { rows: importLimits.maxRows, size: importSizeMB })}
                    </p>
                    <p className="text-xs text-muted-foreground">{t("headerRowNote")}</p>
                  </div>

                  {dataFormat === "csv" && (
                    <div className="space-y-2">
                      <Label>{t("delimiter")}</Label>
                      <Select value={delimiter} onValueChange={(value) => setDelimiter(value)}>
                        <SelectTrigger>
                          <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                          {delimiterOptions.map((option) => (
                            <SelectItem key={option.value} value={option.value}>
                              {option.label}
                            </SelectItem>
                          ))}
                        </SelectContent>
                      </Select>
                    </div>
                  )}

                  {dataFormat === "excel" && (
                    <div className="space-y-2">
                      <Label>{t("sheetAutoLabel")}</Label>
                      <p className="text-sm text-muted-foreground">
                        {loadingPreview
                          ? t("sheetAutoLoading")
                          : detectedSheet
                            ? t("sheetAutoValue", { sheet: detectedSheet })
                            : t("sheetAutoUnknown")}
                      </p>
                    </div>
                  )}

                  {previewRequiresAutoGenerated && (
                    <div className="space-y-2">
                      <div className="flex items-start gap-sm">
                        <Checkbox
                          checked={allowAutoGenerated}
                          onCheckedChange={(value) => setAllowAutoGenerated(Boolean(value))}
                        />
                        <Label>{t("allowAutoGeneratedLabel")}</Label>
                      </div>
                      <p className="text-xs text-muted-foreground">
                        {t("allowAutoGeneratedHelp", {
                          columns: previewAutoGeneratedColumns.join(", "),
                        })}
                      </p>
                    </div>
                  )}

                  {(preview || previewError || loadingPreview) && (
                    <div className="space-y-4">
                      {loadingPreview ? (
                        <div className="space-y-2">
                          <Label>{t("previewTitle")}</Label>
                          <div className="border rounded-lg p-4">
                            <p className="text-xs text-muted-foreground">{t("previewLoading")}</p>
                            <div className="mt-3 space-y-2">
                              <div className="h-2 w-1/3 rounded-full bg-muted/70 animate-pulse" />
                              <div className="h-2 w-2/3 rounded-full bg-muted/60 animate-pulse" />
                              <div className="h-2 w-1/2 rounded-full bg-muted/60 animate-pulse" />
                            </div>
                          </div>
                        </div>
                    ) : previewError ? (
                      <div className="space-y-2">
                        <Label>{t("previewTitle")}</Label>
                        <div className="border border-destructive/40 rounded-lg p-3 text-sm text-destructive">
                          {t("previewFailed", { message: previewErrorMessage ?? t("import.validation.generic") })}
                        </div>
                      </div>
                    ) : (
                        <>
                          <div className="space-y-2">
                            <Label>{t("importMode")}</Label>
                            <Select value={dataMode} onValueChange={(value) => setDataMode(value as ImportMode)}>
                              <SelectTrigger>
                                <SelectValue />
                              </SelectTrigger>
                              <SelectContent>
                                {importModeOptions.map((option) => (
                                  <SelectItem key={option.value} value={option.value}>
                                    {option.label}
                                  </SelectItem>
                                ))}
                              </SelectContent>
                            </Select>
                            {dataMode === ImportMode.Overwrite && (
                              <p className="text-xs text-muted-foreground">
                                {t("overwriteWarning")}
                              </p>
                            )}
                          </div>

                          <div className="space-y-2">
                            <Label>{t("previewTitle")}</Label>
                            {blockingValidationMessage && (
                              <div className="border border-destructive/40 bg-destructive/10 rounded-lg p-3 text-sm text-destructive">
                                {t("previewValidationFailed", { message: blockingValidationMessage })}
                              </div>
                            )}
                            {autoGeneratedBlocked && (
                              <div className="border border-destructive/40 bg-destructive/10 rounded-lg p-3 text-sm text-destructive">
                                {autoGeneratedBlockMessage}
                              </div>
                            )}
                            <div className="border rounded-lg overflow-hidden">
                              <div className="overflow-x-auto">
                                <table className="min-w-full text-sm">
                                  <thead>
                                    <tr className="border-b">
                                      {preview!.Columns.map((col) => (
                                        <th key={col} className="text-left font-medium px-3 py-2 whitespace-nowrap">
                                          {col}
                                        </th>
                                      ))}
                                    </tr>
                                  </thead>
                                  <tbody>
                                    {previewRows.map((row, rowIdx) => (
                                      <tr key={`${rowIdx}`} className="border-b last:border-b-0">
                                        {row.map((cell, cellIdx) => (
                                          <td key={`${rowIdx}-${cellIdx}`} className="px-3 py-2 whitespace-nowrap">
                                            {cell}
                                          </td>
                                        ))}
                                      </tr>
                                    ))}
                                  </tbody>
                                </table>
                              </div>
                            </div>
                            {previewIsTruncated && (
                              <p className="text-xs text-muted-foreground">{t("previewTruncated")}</p>
                            )}
                          </div>
                        </>
                      )}
                    </div>
                  )}
                </>
              ) : (
                <>
                  <div className="space-y-2">
                    <Label>{t("sqlFile")}</Label>
                    <Input
                      type="file"
                      accept=".sql,text/sql"
                      onClick={(event) => {
                        (event.target as HTMLInputElement).value = "";
                      }}
                      onChange={(event) => {
                        const file = event.target.files?.[0] ?? null;
                        if (file && file.size > importLimits.maxFileSizeBytes) {
                          toast.error(t("fileTooLarge", { size: importSizeMB }));
                          event.target.value = "";
                          return;
                        }
                        setSqlFile(file);
                      }}
                    />
                  </div>

                  <div className="space-y-2">
                    <Label>{t("sqlPaste")}</Label>
                    <div className="h-40 border rounded-lg overflow-hidden">
                      <CodeEditor
                        value={sqlText}
                        setValue={setSqlText}
                        language="sql"
                      />
                    </div>
                  </div>

                  <p className="text-xs text-muted-foreground">{t("sqlTransactionNote")}</p>
                  <div className="space-y-2">
                    <div className="flex items-start gap-sm">
                      <Checkbox
                        checked={sqlConfirmed}
                        onCheckedChange={(value) => setSqlConfirmed(Boolean(value))}
                      />
                      <Label>{t("sqlConfirm")}</Label>
                    </div>
                    <p className="text-xs text-muted-foreground">{t("sqlScopeWarning")}</p>
                  </div>
                </>
              )}
            </div>
          </div>
        </div>

        <SheetFooter className="flex gap-sm px-0 mt-4">
          <Button variant="secondary" onClick={() => onOpenChange(false)}>
            {t("cancel")}
          </Button>
          {mode === "data" ? (
            <Button
              onClick={handleImportData}
              disabled={
                loadingImport ||
                loadingPreview ||
                !preview ||
                !previewMapping ||
                Boolean(blockingValidationMessage) ||
                autoGeneratedBlocked
              }
            >
              {loadingImport ? t("importing") : t("import")}
            </Button>
          ) : (
            <Button onClick={handleImportSQL} disabled={loadingSQL || !sqlConfirmed}>
              {loadingSQL ? t("importing") : t("import")}
            </Button>
          )}
        </SheetFooter>
      </SheetContent>
    </Sheet>
  );
};
