// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package types

import (
	"encoding/json"
	"fmt"

	baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
	"github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"
)

type AgentActionType string

const (
	AgentActionTypeListTables        AgentActionType = "ListTables"
	AgentActionTypeDescribeTable     AgentActionType = "DescribeTable"
	AgentActionTypeShowRelationships AgentActionType = "ShowRelationships"
	AgentActionTypeExecuteSQL        AgentActionType = "ExecuteSQL"
	AgentActionTypeFinalAnswer       AgentActionType = "FinalAnswer"
)

// Values returns all allowed values for the AgentActionType type.
func (AgentActionType) Values() []AgentActionType {
	return []AgentActionType{
		AgentActionTypeListTables,
		AgentActionTypeDescribeTable,
		AgentActionTypeShowRelationships,
		AgentActionTypeExecuteSQL,
		AgentActionTypeFinalAnswer,
	}
}

// IsValid checks whether the given AgentActionType value is valid.
func (e AgentActionType) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for AgentActionType.
func (e AgentActionType) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid AgentActionType: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for AgentActionType.
func (e *AgentActionType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = AgentActionType(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid AgentActionType: %q", s)
	}
	return nil
}

func (e *AgentActionType) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "AgentActionType" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.AgentActionType, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = AgentActionType(value)
}

func (e AgentActionType) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("AgentActionType", string(e), false)
}

func (e AgentActionType) BamlTypeName() string {
	return "AgentActionType"
}

type ChatMessageType string

const (
	ChatMessageTypeSQL     ChatMessageType = "SQL"
	ChatMessageTypeMESSAGE ChatMessageType = "MESSAGE"
	ChatMessageTypeERROR   ChatMessageType = "ERROR"
)

// Values returns all allowed values for the ChatMessageType type.
func (ChatMessageType) Values() []ChatMessageType {
	return []ChatMessageType{
		ChatMessageTypeSQL,
		ChatMessageTypeMESSAGE,
		ChatMessageTypeERROR,
	}
}

// IsValid checks whether the given ChatMessageType value is valid.
func (e ChatMessageType) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for ChatMessageType.
func (e ChatMessageType) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid ChatMessageType: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for ChatMessageType.
func (e *ChatMessageType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = ChatMessageType(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid ChatMessageType: %q", s)
	}
	return nil
}

func (e *ChatMessageType) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "ChatMessageType" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.ChatMessageType, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = ChatMessageType(value)
}

func (e ChatMessageType) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("ChatMessageType", string(e), false)
}

func (e ChatMessageType) BamlTypeName() string {
	return "ChatMessageType"
}

type OperationType string

const (
	OperationTypeGET    OperationType = "GET"
	OperationTypeINSERT OperationType = "INSERT"
	OperationTypeUPDATE OperationType = "UPDATE"
	OperationTypeDELETE OperationType = "DELETE"
	OperationTypeCREATE OperationType = "CREATE"
	OperationTypeALTER  OperationType = "ALTER"
	OperationTypeDROP   OperationType = "DROP"
	OperationTypeTEXT   OperationType = "TEXT"
)

// Values returns all allowed values for the OperationType type.
func (OperationType) Values() []OperationType {
	return []OperationType{
		OperationTypeGET,
		OperationTypeINSERT,
		OperationTypeUPDATE,
		OperationTypeDELETE,
		OperationTypeCREATE,
		OperationTypeALTER,
		OperationTypeDROP,
		OperationTypeTEXT,
	}
}

// IsValid checks whether the given OperationType value is valid.
func (e OperationType) IsValid() bool {

	for _, v := range e.Values() {
		if e == v {
			return true
		}
	}
	return false

}

// MarshalJSON customizes JSON marshaling for OperationType.
func (e OperationType) MarshalJSON() ([]byte, error) {
	if !e.IsValid() {
		return nil, fmt.Errorf("invalid OperationType: %q", e)
	}
	return json.Marshal(string(e))
}

// UnmarshalJSON customizes JSON unmarshaling for OperationType.
func (e *OperationType) UnmarshalJSON(data []byte) error {
	var s string
	if err := json.Unmarshal(data, &s); err != nil {
		return err
	}
	*e = OperationType(s)
	if !e.IsValid() {
		return fmt.Errorf("invalid OperationType: %q", s)
	}
	return nil
}

func (e *OperationType) Decode(holder *cffi.CFFIValueEnum, typeMap baml.TypeMap) {
	name := holder.Name
	if name.Name != "OperationType" && name.Namespace != cffi.CFFITypeNamespace_TYPES {
		panic(fmt.Sprintf("expected types.OperationType, got %s.%s", string(name.Namespace.String()), string(name.Name)))
	}
	value := holder.Value
	*e = OperationType(value)
}

func (e OperationType) Encode() (*cffi.HostValue, error) {
	return baml.EncodeEnum("OperationType", string(e), false)
}

func (e OperationType) BamlTypeName() string {
	return "OperationType"
}
