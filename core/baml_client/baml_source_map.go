// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package baml_client

var file_map = map[string]string{

	"agent_step.baml": "// Agentic Chat Mode for WhoDB\n// Called in a loop to explore schema, execute queries, self-correct, and build answers\n\n// Action types the agent can take\nenum AgentActionType {\n  ListTables @alias(\"list_tables\") @description(\"List all tables in the schema\")\n  DescribeTable @alias(\"describe_table\") @description(\"Get columns and types for a specific table\")\n  ShowRelationships @alias(\"show_relationships\") @description(\"Get foreign key relationships for a table\")\n  ExecuteSQL @alias(\"execute_sql\") @description(\"Execute a SQL query against the database\")\n  FinalAnswer @alias(\"final_answer\") @description(\"Return the final answer to the user\")\n}\n\n// Structured action returned by each agent step\nclass AgentAction {\n  action AgentActionType @description(\"The action to take\")\n  argument string? @description(\"Table name for describe_table/show_relationships, or SQL query for execute_sql\")\n  message string? @description(\"Status message to show the user explaining what you're doing\")\n  sql string? @description(\"For final_answer: optional SQL query to display alongside the answer\")\n  requires_confirmation bool @description(\"Whether this action requires user confirmation before executing (for mutations)\")\n}\n\n// Single step in the agent loop\nfunction AgentStep(\n  context: DatabaseContext,\n  tool_history: string,\n  user_query: string\n) -> AgentAction {\n  client DefaultClient\n  prompt #\"\n    You are a database assistant that explores schemas, runs queries, and answers questions step by step.\n\n    Database: {{ context.database_type }}\n    Schema: {{ context.schema }}\n\n    Available Tables and Fields:\n    {{ context.tables_and_fields }}\n\n    Previous Conversation:\n    {{ context.previous_conversation }}\n\n    ### Tool History (actions taken so far in this turn):\n    {{ tool_history }}\n\n    ### User's Question:\n    {{ user_query }}\n\n    ### Available Actions:\n    You must return ONE action per step. Choose the best next action:\n\n    1. **list_tables** - List all tables. Use when you need to discover what tables exist.\n       - argument: not needed\n       - message: explain what you're doing\n\n    2. **describe_table** - Get columns for a specific table. Use to understand table structure before writing SQL.\n       - argument: the table name (without schema prefix)\n       - message: explain what you're doing\n\n    3. **show_relationships** - Get foreign key relationships for a table. Use to understand joins.\n       - argument: the table name (without schema prefix)\n       - message: explain what you're doing\n\n    4. **execute_sql** - Run a SQL query. Use after you understand the schema well enough.\n       - argument: the complete SQL query\n       - message: explain what the query does\n       {% if context.schema %}\n       - IMPORTANT: EVERY table reference MUST include the schema: {{ context.schema }}.table_name\n       {% else %}\n       - IMPORTANT: Do NOT add any schema prefix to table names\n       {% endif %}\n\n    5. **final_answer** - Return your answer to the user. Use when you have all information needed.\n       - argument: not needed\n       - message: your complete answer to the user\n       - sql: optionally include a SQL query to display\n\n    ### Strategy:\n    - If the user asks about data, explore the schema first (describe relevant tables), then write SQL\n    - If a previous SQL query errored (visible in tool_history), analyze the error and fix the query\n    - If you already have query results in tool_history, summarize them in your final_answer\n    - For mutations (INSERT/UPDATE/DELETE/CREATE/ALTER/DROP), set requires_confirmation to true\n    - Be efficient: don't list_tables if tables_and_fields already has the info\n    - Reach final_answer within a few steps - don't over-explore\n    - NEVER repeat an action that already succeeded in tool_history\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Summarize conversation history when it gets too long\nfunction SummarizeConversation(\n  conversation: string,\n  database_type: string\n) -> string {\n  client DefaultClient\n  prompt #\"\n    Summarize this database chat conversation concisely, preserving:\n    - Key facts learned about the database schema\n    - Important query results and their meaning\n    - The user's ongoing goals or questions\n    - Any errors encountered and how they were resolved\n\n    Database type: {{ database_type }}\n\n    Conversation to summarize:\n    {{ conversation }}\n\n    Return a concise summary (aim for ~20% of the original length).\n    Focus on information that would be needed to continue the conversation.\n\n    {{ ctx.output_format }}\n  \"#\n}\n",
	"clients.baml":    "// Learn more about clients at https://docs.boundaryml.com/docs/snippets/clients/overview\n//\n// NOTE: These are fallback clients used when dynamic client creation fails.\n// Primary client configuration is done at runtime via CreateDynamicBAMLClient()\n// using user-selected providers, models, and API keys from the UI.\n\n// Default fallback client - uses OpenAI if environment variable is set\nclient<llm> DefaultClient {\n  provider openai\n  retry_policy Exponential\n  options {\n    model \"gpt-4o\"\n    api_key env.OPENAI_API_KEY\n  }\n}\n\n// Retry policies for robust API calls\nretry_policy Constant {\n  max_retries 3\n  strategy {\n    type constant_delay\n    delay_ms 200\n  }\n}\n\nretry_policy Exponential {\n  max_retries 2\n  strategy {\n    type exponential_backoff\n    delay_ms 300\n    multiplier 1.5\n    max_delay_ms 10000\n  }\n}\n",
	"generators.baml": "// This helps use auto generate libraries you can use in the language of\n// your choice. You can have multiple generators if you use multiple languages.\n// Just ensure that the output_dir is different for each generator.\ngenerator target {\n    // Valid values: \"python/pydantic\", \"typescript\", \"ruby/sorbet\", \"rest/openapi\"\n    output_type \"go\"\n\n    // Where the generated code will be saved (relative to baml_src/)\n    output_dir \"../\"\n\n    // The version of the BAML package you have installed (e.g. same version as your baml-py or @boundaryml/baml).\n    // The BAML VSCode extension version should also match this version.\n    version \"0.218.1\"\n\n    // 'baml-cli generate' will run this after generating go code\n    // This command will be run from within $output_dir/baml_client\n    on_generate \"gofmt -w . && goimports -w .\"\n\n    // Your Go packages name as specified in go.mod\n    // We need this to generate correct imports in the generated baml_client\n    client_package_name \"github.com/clidey/whodb/core\"\n}\n",
	"sql_chat.baml":   "// SQL Query Generation for WhoDB\n// This BAML schema defines structured SQL generation using AI models\n\n// Database operation types\nenum OperationType {\n  GET @alias(\"get\") @description(\"SELECT queries to retrieve data\")\n  INSERT @alias(\"insert\") @description(\"INSERT queries to add data\")\n  UPDATE @alias(\"update\") @description(\"UPDATE queries to modify data\")\n  DELETE @alias(\"delete\") @description(\"DELETE queries to remove data\")\n  CREATE @alias(\"create\") @description(\"CREATE TABLE, CREATE INDEX and other schema creation operations\")\n  ALTER @alias(\"alter\") @description(\"ALTER TABLE and other schema modification operations\")\n  DROP @alias(\"drop\") @description(\"DROP TABLE, DROP INDEX and other schema deletion operations\")\n  TEXT @alias(\"text\") @description(\"General text responses without SQL\")\n}\n\n// Chat message type\nenum ChatMessageType {\n  SQL @alias(\"sql\") @description(\"SQL query response\")\n  MESSAGE @alias(\"message\") @description(\"Textual response without query\")\n  ERROR @alias(\"error\") @description(\"Error response\")\n}\n\n// Chat response structure matching engine.ChatMessage\nclass ChatResponse {\n  type ChatMessageType @description(\"Type of response: sql or message\")\n  operation OperationType? @description(\"SQL operation type if applicable\")\n  text string @description(\"The SQL query or response text\")\n}\n\n// Database context for SQL generation\nclass DatabaseContext {\n  database_type string @description(\"Database type (e.g., PostgreSQL, MySQL)\")\n  schema string @description(\"Database schema name\")\n  tables_and_fields string @description(\"Available tables with their field definitions\")\n  previous_conversation string @description(\"Previous conversation history for context\")\n}\n\n// Main function to generate SQL queries from natural language\nfunction GenerateSQLQuery(\n  context: DatabaseContext,\n  user_query: string\n) -> ChatResponse[] {\n  client DefaultClient\n  prompt #\"\n    You are a friendly and helpful data engineer working with a {{ context.database_type }} database. Think of yourself as a colleague who's here to help explore and understand the data.\n\n    Database Context:\n    Schema: {{ context.schema }}\n\n    Available Tables and Fields:\n    {{ context.tables_and_fields }}\n\n    ### CRITICAL: JSON FORMAT ONLY - NO EXCEPTIONS\n\n    YOU MUST RETURN ONLY A JSON ARRAY. START YOUR RESPONSE WITH [ AND END WITH ]\n    NO PLAIN TEXT. NO EXPLANATIONS OUTSIDE JSON. ONLY THE JSON ARRAY.\n\n    EXACT FORMAT:\n    [{\"type\": \"message\", \"operation\": null, \"text\": \"your message here\"}]\n\n    For ONLY simple greetings (Hi, Hello, Hey - nothing else):\n    [{\"type\": \"message\", \"operation\": null, \"text\": \"Hi! I'm here to help you work with the {% if context.schema %}{{ context.schema }} {% endif %}database. What would you like to know?\"}]\n\n    For any other request (even if it starts with Hi), ANSWER THE ACTUAL REQUEST, don't just greet.\n\n    For data requests, return TWO items (message explaining + SQL query):\n    [{\"type\": \"message\", \"operation\": null, \"text\": \"I'll get the users for you.\"}, {\"type\": \"sql\", \"operation\": \"get\", \"text\": \"SELECT * FROM {% if context.schema %}{{ context.schema }}.{% endif %}users LIMIT 100;\"}]\n\n    ### CRITICAL: ALWAYS RESPOND TO THE USER'S ACTUAL QUESTION\n    - READ the user's request carefully and answer THAT SPECIFIC question\n    - DO NOT give generic greetings unless the user is specifically greeting you (hi, hello, etc.)\n    - If the user asks you to do something specific (create data, run a query, etc.), DO THAT - don't give an introduction\n    - ONLY mention tables that ACTUALLY EXIST in the \"Available Tables and Fields\" section above\n    - If NO tables are listed in \"Available Tables and Fields\", DO NOT mention any table names\n    - NEVER hallucinate or make up table names, database names, or data that isn't provided in the context\n\n    ### Your Personality and Approach:\n    - Be warm, conversational, and approachable - like a helpful colleague, not a robot\n    - When greeting or introducing yourself, ONLY talk about DATA that ACTUALLY EXISTS in the context above\n    - Show genuine interest in helping the user understand their data\n    - Provide context and insights about the data, not just queries\n    - Ask clarifying questions when needed\n    - Explain your reasoning and thought process\n    - Be proactive in suggesting relevant analyses based on ACTUAL available tables only\n\n    ### Response Format:\n    You must structure your responses with these fields:\n\n    **type** (required):\n      - \"message\" - for conversational text, explanations, greetings, or insights\n      - \"sql\" - when generating an actual SQL query\n\n    **operation** (required when type=\"sql\", otherwise null):\n      - \"get\" - for SELECT queries to retrieve data\n      - \"insert\" - for adding new records\n      - \"update\" - for modifying existing records\n      - \"delete\" - for removing records\n      - \"create\" - for CREATE TABLE, CREATE INDEX and other schema creation operations\n      - \"alter\" - for ALTER TABLE and other schema modification operations\n      - \"drop\" - for DROP TABLE, DROP INDEX and other schema deletion operations\n\n    **text** (required):\n      - Your conversational message, explanation, or SQL query\n\n    ### CRITICAL SQL RULE - READ THIS CAREFULLY:\n    {% if context.schema %}\n    **EVERY table reference in SQL queries MUST include the schema name: {{ context.schema }}.table_name**\n\n    ❌ WRONG: SELECT * FROM users\n    ❌ WRONG: SELECT * FROM orders\n    ❌ WRONG: SELECT * FROM test_casting\n\n    ✅ CORRECT: SELECT * FROM {{ context.schema }}.users\n    ✅ CORRECT: SELECT * FROM {{ context.schema }}.orders\n    ✅ CORRECT: SELECT * FROM {{ context.schema }}.test_casting\n\n    This is MANDATORY for all queries. Queries without schema names WILL FAIL.\n    {% else %}\n    **This database does NOT use schemas. Reference tables by name only, WITHOUT any schema prefix.**\n\n    ❌ WRONG: SELECT * FROM .users (no leading dot!)\n    ❌ WRONG: SELECT * FROM schema.users (no schema prefix!)\n\n    ✅ CORRECT: SELECT * FROM users\n    ✅ CORRECT: SELECT * FROM orders\n    ✅ CORRECT: SELECT * FROM test_casting\n\n    This is MANDATORY for all queries. Do NOT add any schema or dot prefix.\n    {% endif %}\n\n    ### How to Handle Common Scenarios:\n\n    {% if context.tables_and_fields and context.tables_and_fields|trim %}\n    **When tables exist - Greetings (Hi, Hello, etc.):**\n    - Warmly greet the user\n    - Briefly mention what database/schema you're working with\n    - Mention 2-3 ACTUAL tables from the available tables (ONLY use tables from the \"Available Tables and Fields\" section above - NEVER make up table names)\n    - Invite them to ask about specific data or analyses\n    - Example: \"Hi! I'm here to help you explore the {% if context.schema %}{{ context.schema }} {% endif %}database. I can see you have tables like [ACTUAL TABLE NAMES FROM CONTEXT]. What would you like to know?\"\n\n    **When tables exist - \"What can you do?\" or similar:**\n    - Focus on the DATA that ACTUALLY EXISTS\n    - Mention the types of analyses possible with their ACTUAL tables (from \"Available Tables and Fields\")\n    - Give concrete examples based on ONLY the tables listed above - NEVER mention tables that aren't in the list\n    - Example: \"I can help you explore your data! You have [ACTUAL TABLE NAMES] - we could analyze patterns, look at relationships, or explore any specific metrics. What would you like to explore?\"\n    {% else %}\n    **When NO tables exist - Empty database:**\n    - Acknowledge that the database/schema currently has no tables\n    - Explain that you can help create tables or run queries once tables exist\n    - Be honest and helpful\n    - Example: \"Hi! I'm here to help you work with the {% if context.schema %}{{ context.schema }} {% endif %}database. It looks like there are no tables set up yet. I can help you create tables or run queries once your schema has data. What would you like to do?\"\n\n    **When NO tables exist - Data requests:**\n    - Politely explain that no tables exist yet\n    - Cannot generate SELECT queries for non-existent tables\n    - Offer to help create tables instead\n    - Example: \"I don't see any tables in the {% if context.schema %}{{ context.schema }} {% endif %}database yet. Would you like me to help you create some tables first?\"\n    {% endif %}\n\n    **Data exploration requests:**\n    - First provide a brief explanation of what you'll retrieve and why it's useful\n    - Then provide the SQL query {% if context.schema %}with FULL schema names{% else %}WITHOUT any schema prefix{% endif %}\n    - Return both a message and a sql response\n    - Example query structure: SELECT * FROM {% if context.schema %}{{ context.schema }}.{% endif %}users LIMIT 100;\n\n    **Schema modification requests (CREATE TABLE, ALTER TABLE, DROP TABLE):**\n    - First provide a brief explanation of what you'll do\n    - Then provide the DDL SQL query {% if context.schema %}with FULL schema names{% else %}WITHOUT any schema prefix{% endif %}\n    - Return both a message and a sql response with the appropriate operation type (create/alter/drop)\n    - Always use appropriate data types for the target database\n    - Example: [{\"type\": \"message\", \"operation\": null, \"text\": \"I'll create a countries table with id and name columns.\"}, {\"type\": \"sql\", \"operation\": \"create\", \"text\": \"CREATE TABLE {% if context.schema %}{{ context.schema }}.{% endif %}countries (id INTEGER PRIMARY KEY, name VARCHAR(100));\"}]\n\n    **Ambiguous requests:**\n    - Ask friendly clarifying questions\n    - Suggest a few specific options based on available data\n    - Help narrow down what they're looking for\n\n    ### SQL Query Examples ({% if context.schema %}Always use schema prefix!{% else %}NO schema prefix for this database{% endif %}):\n\n    **Simple select:**\n    SELECT * FROM {% if context.schema %}{{ context.schema }}.{% endif %}users LIMIT 100;\n\n    **Join query:**\n    SELECT u.name, o.total\n    FROM {% if context.schema %}{{ context.schema }}.{% endif %}users u\n    JOIN {% if context.schema %}{{ context.schema }}.{% endif %}orders o ON u.id = o.user_id\n    LIMIT 50;\n\n    **Aggregate query:**\n    SELECT status, COUNT(*) as count\n    FROM {% if context.schema %}{{ context.schema }}.{% endif %}orders\n    GROUP BY status;\n\n    ### Additional Guidelines:\n    - For large result sets, warn the user and add LIMIT clauses\n    - Before DELETE/UPDATE operations, always confirm with the user first\n    - When you can provide both explanation and query, do so (message first, then sql)\n\n    ### CRITICAL: ONE SQL STATEMENT PER RESPONSE OBJECT\n    **Each SQL query MUST be in its own separate ChatResponse object in the array.**\n\n    ❌ WRONG - Multiple statements in one text field:\n    [{\"type\": \"sql\", \"operation\": \"get\", \"text\": \"SELECT * FROM schema.users; SELECT * FROM schema.orders;\"}]\n\n    ✅ CORRECT - Separate objects for each query:\n    [\n      {\"type\": \"message\", \"operation\": null, \"text\": \"I'll get the users and orders for you.\"},\n      {\"type\": \"sql\", \"operation\": \"get\", \"text\": \"SELECT * FROM schema.users LIMIT 100;\"},\n      {\"type\": \"sql\", \"operation\": \"get\", \"text\": \"SELECT * FROM schema.orders LIMIT 100;\"}\n    ]\n\n    This is MANDATORY because databases can only execute one statement at a time.\n    For complex requests requiring multiple queries, return multiple sql objects.\n\n    Previous Conversation:\n    {{ context.previous_conversation }}\n\n    User's Request:\n    {{ user_query }}\n\n    {{ ctx.output_format }}\n  \"#\n}\n\n// Test cases\ntest simple_select {\n  functions [GenerateSQLQuery]\n  args {\n    context {\n      database_type \"PostgreSQL\"\n      schema \"public\"\n      tables_and_fields #\"\n        table: users\n        - id (integer)\n        - name (varchar)\n        - email (varchar)\n        - created_at (timestamp)\n      \"#\n      previous_conversation \"\"\n    }\n    user_query \"Show me all users\"\n  }\n}\n\ntest complex_query_with_join {\n  functions [GenerateSQLQuery]\n  args {\n    context {\n      database_type \"PostgreSQL\"\n      schema \"public\"\n      tables_and_fields #\"\n        table: users\n        - id (integer)\n        - name (varchar)\n        - email (varchar)\n\n        table: orders\n        - id (integer)\n        - user_id (integer)\n        - total (decimal)\n        - created_at (timestamp)\n      \"#\n      previous_conversation \"\"\n    }\n    user_query \"Show me all orders with user names for orders over $100\"\n  }\n}\n\n// Function to generate a short chat title from the first user query\nfunction GenerateChatTitle(\n  user_query: string\n) -> string {\n  client DefaultClient\n  prompt #\"\n    Generate a simple, natural title (maximum 4 words) for a chat that starts with: \"{{ user_query }}\"\n\n    Use casual, everyday language. Avoid formal words like \"Request\", \"Query\", \"Generation\", \"Analysis\".\n\n    IMPORTANT RULES:\n    1. If the query is unclear, too vague, or doesn't have enough context to create a meaningful title, return an EMPTY string (nothing at all).\n    2. If you can create a meaningful, specific title, return it.\n    3. Do NOT return generic titles like \"General Chat\", \"New Chat\", \"Conversation\", \"Support\", \"Help\" - instead return EMPTY.\n\n    Examples of when to return EMPTY:\n    - \"Hi\" → (empty)\n    - \"Hello\" → (empty)\n    - \"Hey\" → (empty)\n    - \"Blah\" → (empty)\n    - \"Test\" → (empty)\n    - \"?\" → (empty)\n\n    Examples of good titles:\n    - \"Show me all users\" → \"All Users\"\n    - \"Give me all the users\" → \"All Users\"\n    - \"What are the total sales by region?\" → \"Sales by Region\"\n    - \"How many orders were placed last month?\" → \"Last Month Orders\"\n    - \"Create a table for products\" → \"Create Products Table\"\n\n    Return ONLY the title or empty. No quotes, no explanations, no punctuation.\n\n    {{ ctx.output_format }}\n  \"#\n}\n",
}

func getBamlFiles() map[string]string {
	return file_map
}
