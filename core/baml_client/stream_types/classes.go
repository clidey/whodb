// ----------------------------------------------------------------------------
//
//  Welcome to Baml! To use this generated code, please run the following:
//
//  $ go get github.com/boundaryml/baml
//
// ----------------------------------------------------------------------------

// This file was generated by BAML: please do not edit it. Instead, edit the
// BAML files and re-generate this code using: baml-cli generate
// You can install baml-cli with:
//  $ go install github.com/boundaryml/baml/baml-cli

package stream_types

import (
	"fmt"

	baml "github.com/boundaryml/baml/engine/language_client_go/pkg"
	"github.com/boundaryml/baml/engine/language_client_go/pkg/cffi"

	"github.com/clidey/whodb/core/baml_client/types"
)

type AgentAction struct {
	Action                *types.AgentActionType `json:"action"`
	Argument              *string                `json:"argument"`
	Message               *string                `json:"message"`
	Sql                   *string                `json:"sql"`
	Requires_confirmation *bool                  `json:"requires_confirmation"`
}

func (c *AgentAction) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "AgentAction" {
		panic(fmt.Sprintf("expected AgentAction, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "action":
			c.Action = baml.Decode(valueHolder).Interface().(*types.AgentActionType)

		case "argument":
			c.Argument = baml.Decode(valueHolder).Interface().(*string)

		case "message":
			c.Message = baml.Decode(valueHolder).Interface().(*string)

		case "sql":
			c.Sql = baml.Decode(valueHolder).Interface().(*string)

		case "requires_confirmation":
			c.Requires_confirmation = baml.Decode(valueHolder).Interface().(*bool)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class AgentAction", key))

		}
	}

}

func (c AgentAction) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["action"] = c.Action

	fields["argument"] = c.Argument

	fields["message"] = c.Message

	fields["sql"] = c.Sql

	fields["requires_confirmation"] = c.Requires_confirmation

	return baml.EncodeClass("AgentAction", fields, nil)
}

func (c AgentAction) BamlTypeName() string {
	return "AgentAction"
}

type ChatResponse struct {
	Type      *types.ChatMessageType `json:"type"`
	Operation *types.OperationType   `json:"operation"`
	Text      *string                `json:"text"`
}

func (c *ChatResponse) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "ChatResponse" {
		panic(fmt.Sprintf("expected ChatResponse, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "type":
			c.Type = baml.Decode(valueHolder).Interface().(*types.ChatMessageType)

		case "operation":
			c.Operation = baml.Decode(valueHolder).Interface().(*types.OperationType)

		case "text":
			c.Text = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class ChatResponse", key))

		}
	}

}

func (c ChatResponse) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["type"] = c.Type

	fields["operation"] = c.Operation

	fields["text"] = c.Text

	return baml.EncodeClass("ChatResponse", fields, nil)
}

func (c ChatResponse) BamlTypeName() string {
	return "ChatResponse"
}

type DatabaseContext struct {
	Database_type         *string `json:"database_type"`
	Schema                *string `json:"schema"`
	Tables_and_fields     *string `json:"tables_and_fields"`
	Previous_conversation *string `json:"previous_conversation"`
}

func (c *DatabaseContext) Decode(holder *cffi.CFFIValueClass, typeMap baml.TypeMap) {
	typeName := holder.Name
	if typeName.Namespace != cffi.CFFITypeNamespace_STREAM_TYPES {
		panic(fmt.Sprintf("expected cffi.CFFITypeNamespace_STREAM_TYPES, got %s", string(typeName.Namespace.String())))
	}
	if typeName.Name != "DatabaseContext" {
		panic(fmt.Sprintf("expected DatabaseContext, got %s", typeName.Name))
	}

	for _, field := range holder.Fields {
		key := field.Key
		valueHolder := field.Value
		switch key {

		case "database_type":
			c.Database_type = baml.Decode(valueHolder).Interface().(*string)

		case "schema":
			c.Schema = baml.Decode(valueHolder).Interface().(*string)

		case "tables_and_fields":
			c.Tables_and_fields = baml.Decode(valueHolder).Interface().(*string)

		case "previous_conversation":
			c.Previous_conversation = baml.Decode(valueHolder).Interface().(*string)

		default:

			panic(fmt.Sprintf("unexpected field: %s in class DatabaseContext", key))

		}
	}

}

func (c DatabaseContext) Encode() (*cffi.HostValue, error) {
	fields := map[string]any{}

	fields["database_type"] = c.Database_type

	fields["schema"] = c.Schema

	fields["tables_and_fields"] = c.Tables_and_fields

	fields["previous_conversation"] = c.Previous_conversation

	return baml.EncodeClass("DatabaseContext", fields, nil)
}

func (c DatabaseContext) BamlTypeName() string {
	return "DatabaseContext"
}
